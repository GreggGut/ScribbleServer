
Presented By Team 8: (2B)V~(2B) 

 Grzegorz Gut 5791715
Oscar Tsui 9474625
Michael Goodman 5715903
Alexander St-Louis 9593810 


 
Table of Contents
1	Chapter 1: Scope, Research, and Project Definition	1
1.1	Abstract	2
1.2	About this Document	3
1.2.1	Organization of the final design report	3
1.3	Introduction	5
1.4	Background & Motivation	6
1.5	Problem Statement	6
1.6	Constraints	7
1.6.1	Physical Constraints	7
1.6.2	Environmental constraints	7
1.7	Functional Requirements	7
1.8	Research of the Existing Solutions	8
1.8.1	Wheels	8
1.8.2	Steering	10
1.8.3	Motors	11
1.8.4	Batteries (Heart of the Robot)	14
1.8.5	Motor Control Fundamentals	15
1.8.6	Sensors (eyes of the robot)	20
1.8.7	Existing robots	22
1.9	Evaluating Alternatives	24
1.9.1	Chassis	25
1.9.2	Motor	25
1.9.3	Motor driver	26
1.9.4	Microcontroller	27
1.9.5	Distance Sensors	28
1.9.6	Line sensors	29
1.10	The Alternatives	29
1.10.1	Robot 1	29
1.10.2	Robot 2	30
1.11	The choice	31
1.12	Block Diagram	33
1.13	Inputs and Outputs	34
1.13.1	Inputs	34
1.13.2	Outputs	34
1.14	Software Flowchart	35
1.15	Work Breakdown Structure	36
1.16	Schematic	39
1.17	Description of the Schematic	40
1.17.1	Batteries	40
1.17.2	Double pole Single Throw switch	40
1.17.3	Voltage regulator	41
1.17.4	Analog Infrared sensors	41
1.17.5	Line sensors	41
1.17.6	Push Button	42
1.17.7	Atmega8	42
1.17.8	H-Bridge	42
1.17.9	Motors	42
1.17.10	Resistors	42
1.17.11	Capacitors	43
1.17.12	Inductors	43
1.17.13	ISP	43
1.18	Bill of Materials/Budget/labour	43
1.19	Team Dynamics	44
1.19.1	Member’s Roles & Responsibility	44
1.19.2	Team Task distribution	45
1.19.3	Working agreement	46
1.20	Troubleshooting effort between trials and competition	48
1.21	Methodical testing results	49
1.21.1	Sensor 1	49
1.21.2	Sensor2	50
1.21.3	Sensor 3	51
1.21.4	Sensor 4	52
1.21.5	Sensor 5	53
1.22	Proposed Design	54
1.23	Lessons learned	58
1.23.1	What did you learn and how would you do it better	58
1.23.1	Impact of engineering	58
1.24	Conclusion	59
2	CHAPTER 2: Technical Manual	60
2.1	About this Manual	61
2.1.1	Introduction	61
2.1.2	Scope and Purpose	61
2.1.3	Targeted Audience	61
2.1.4	Organization of this manual	61
2.2	Introduction of the Tautologizer	62
2.2.1	Tautologizer Overview	63
2.2.2	Operating ranges of the circuit components	65
2.2.3	Technical Definition of the Components	65
2.2.4	ATMEGA8L-8PU-ND	66
2.2.5	DB25 Male ISP Cable and Header	66
2.2.6	Chassis	66
2.2.7	Green LED LTL5H3 Series	66
2.2.8	R1/4-220: 1/4 Watt- 220 Ohm Resistor	66
2.2.9	LM7805CT-ND	66
2.2.10	CD224 Ceramic Disc Capacitor .1uf 50V	67
2.2.11	CM334 Ceramic Monolithic Radial Capacitor .33uf	67
2.2.12	Breadboard ABRA - 270	67
2.2.13	RS232 Cable	67
2.2.14	MAX232	67
2.2.15	GP2D12	67
2.2.16	SS-3GLPT	67
2.2.17	Motor GM8	67
2.2.18	Solarbotics GWPM Wheels	68
2.2.19	SN754410N	68
2.2.20	Motor Bracket	68
2.2.21	Contact Switch	68
2.2.22	OPB606A	68
2.2.23	Battery Pack	68
2.2.24	Charger	68
2.3	Instructions for constructing the robot	68
2.3.1	Before robot construction	69
2.3.2	Circuit building	71
2.3.3	Constructing the Rest of the Robot	73
2.4	Block Diagram, Schematic, and software Flowchart	74
2.5	Uploading the software to the robot	77
2.5.1	Step 1	77
2.5.2	Step 2	77
2.5.3	Step 3	77
2.5.4	Step 4	77
2.5.5	Step 5	77
2.5.6	Step 6	77
2.5.7	Step 7	78
3	Chapter 3: User Manual	79
3.1	Welcome	80
3.2	About this Manual	80
3.2.1	Introduction	80
3.2.2	Scope and Purpose	80
3.2.3	Targeted Audience	81
3.2.4	Organization of this manual	81
3.3	Product overview	82
3.4	Operation of the robot	85
3.4.1	How to turn on the robot	85
3.4.2	The environment it will be encountering	86
3.4.3	How it will operate in its environment	87
3.5	Safety Precautions	87
3.6	Maintenance of the Robot	88
3.6.1	Maintaining the power source	88
3.6.2	In the event of a short circuit	89
3.6.3	Rebooting the circuit	89
3.7	Debugging the Robot	89
3.7.1	Check the connections	90
3.7.2	Testing the individual components	90
3.7.3	Debugging the robot as a whole	91
4	Chapter 4: Software	92
5	Chapter 5: Bibliography	112

  










Chapter 1: Scope, Research, and Project Definition 
 
Abstract
Engineers are professionals that take on contracts from clients, and implement their ideas turning it into reality. This document will label the process of how an engineer comes up with the design aspect of a project. This document contains a full design proposal for the tower square defender sumo robot. It includes the problem statement, the constraints, the requirements, the alternatives, and the final robot choice. Furthermore, a complete block diagram shows the inputs and outputs of our overall system. The document also has an algorithm, in the form of a flowchart, in which will specify the tasks that the sumo robot must perform. A detailed project schedule is included to help evaluate the time required for this given project. The schedule includes the design, implementation, and testing of the clients product.
 
About this Document
This document will be introducing the autonomous Tautologizer robot. We will introduce the project definition by client, and determine the problem statement and constraints. We will then evaluate the possible methods of implementation of existing solutions for the electrical and mechanical components along with the evaluation of two possible robot designs. To follow, there will be a full work breakdown structure with visual aids along with the budget. The final robot design after all the modifications will be presented along with the troubleshooting from the robot trials to the final robot design. Experimental results of the final robot designs components will be made available, and finally, a complete technical and user manual will be offered to the customer and operators of the Tautologizer robot.     
Organization of the final design report
Introduction of Chapter 1
This will introduce the need for sumo robots
Problem statement 
This will clearly depict the problem in which a technical designer must solve and produce for the customer
Constraints
The constraints will vary from the restrictions in which the sumo robot will have with regards to the design aspect, as well as the environmental challenges the designer must take into consideration before implementation.
Functional requirements
These are the basic requirements specified by the customer. 
Evaluating the alternatives
The evaluation of the electrical and mechanical components that need to be considered when constructing a sumo robot. 
The Alternatives
These are the possible alternatives in which the designer has come up with to present to the customer.
Block diagram
This section includes a simplified visual representation of the inputs and outputs of the robot design. 
Work Breakdown Structure
A way to visualize the amount of time is required in order to perform certain tasks, as well as seeing dependencies on preceding tasks. This will also indicate the people who are involved with a particular task, as well as who is in charge of completing and responsible of a given task. 
Schematic
This section describes the final schematic design in order to construct the Tautologizer sumo robot. 
Description of the schematic
This section describes the components in detail.  
Bill of materials
A list of the materials required to create or reproduce the sumo robot in question. 
Team Dynamics
This will discuss how the teams working agreement worked out over the course of the project. 
Trouble shooting
Modifications in which needed to be made between the robot trials and the final robot competition. 
Experimental results
Will depict the experimental results the group had to perform before considering the construction of the Tautologizer sumo robot. 
Technical manual - Chapter 2
This section includes a technical manual with which someone may reproduce and reconstruct the Tautologizer robot. It includes the hardware and software standpoint. 
User manual - Chapter 3
A manual in which will aid someone in order to maintain and debug the Tautologizer robot, along with the safety precautions one must consider before operating the robot, and how it will perform in a given environment. 
Introduction                
Robot sumo is a competition in which two robots attempt to push each other out of a ring. The competition will put two robots versus each other, and the goal is to push the opposing robot out of the ring as fast as possible. The arena will contain a 1-foot high tower in the center of the ring that which in turn will give rise to new challenges to the competitors.


Background & Motivation 
For the coen/elec 390 course students are expected to participate in a team design project, in which the team will face both technical and personal challenges. The objective of the course is to build an autonomous sumobot which will outsmart and push the opposing sumobot out of the ring, however; the ultimate goal of the course is for the students to have a greater understanding of what it means to be an engineer.  For many, this will be their first open ended problem, which will require defining the problem, formulating solutions, developing models and presenting their design. Every skill and tool available for the young future engineer will be tested, such as decision making, project management, communication and collaboration. Under tremendous stress team mates will have to learn to work together and rely on one another, while delivering a functional device. Hopefully, at the end of the course, one will have more confidence to tackle complex problems and be ready to work with others in the work force. 
Problem Statement
The engineering challenges for this competition are that the robot must detect its opponent with the help of sensors, and once the opponent has been located, the sumo robot must push the opposing robot out of the ring. Once one of the robots has been pushed outside of the ring, the robot remaining must stay within the ring for at least 10 additional seconds. The time limit for each match is 3 minutes (180 seconds). The materials for the construction of the robot must be authorized or preapproved before any construction. Also the materials used must be as light as possible in order to ensure that the robot operates at the intellectual level and not by its “muscle”. The robot will have its own power source. A robot loses a battle once any of its parts is out of the square i.e. has touched surface outside the outer edge of the square. However a robot may return to battle if it is out of the ring but not once it is out of the square. 
Constraints 
Physical Constraints
Some of the physical constraints of the robot are that it cannot intentionally inflict damage to its opponents, all parts need to be screwed or tie-wrapped to the chassis, and the chassis cannot be modified in any way: no drilling holes, enlarging, bending, or cutting. The robot size cannot exceed the size of the chassis and therefore no part can stick out more than 10 mm before the start and after the end of a round.
Environmental constraints
 The environmental constraints for the robot consist of a ring, a square, and a tower. The ring is an area on the MDF board inside a circle which is approximately 4 feet in diameter. The ring is traced with a black electric tape of 3/4  inch wide. The square is an MDF board which is 4 feet by 4 feet with the ring on it and a tower which lies in the middle. The tower is a cylindrical structure, which is approximately 1 foot in diameter and at least 1 foot tall. 
Functional Requirements
The robot has certain functional requirements which it must satisfy. The robot design must be based on an intellectual factor and not a muscle factor and therefore all chosen parts should be as light as possible and no unnecessary parts should be added as weight. All chosen components must be chosen from a preapproved parts list. The robot's main task is to push opponents out of the ring while signaling victory and remaining within the ring for a minimum of 10 seconds after each victory. Autonomy is one of the main requirements and therefore there cannot be any interaction with the robot once the GO command has been activated. After the GO command, the robot needs to stay inactive for 5 seconds after which it can begin its task to search, detect, and push opponents out of a ring; the robot will be disqualified if it starts to move immediately. Finally, the overall cost for the materials for the robot construction must not exceed 200$.
Research of the Existing Solutions
Wheels
There are several alternatives to choose from when considering the wheels on the sumo-bot. The final choice is important mainly because the wheels chosen have to be able to allow the robot to turn easily, have good traction, and function properly together. 
The two main choices of wheels are traditional wheels or tank-style threads. Each of those two alternatives has their advantages and disadvantages, and the final choice will depend on the overall grade received.
Traditional Wheels
The main advantages of having the traditional wheels are that they have good traction, ease of build and mount easily to the chassis. The number of wheels considered changes the whole maneuvering algorithm, the amount of motors, and their force. Because of these factors, we will consider two wheels, four wheels and six wheels. 
Two Wheels
The advantage of having two wheels attached to the robot is the ease of implementation, ease of control, and quick response time. When considering two wheels we need to take into consideration the stability of the robot, and the total available force. Aside from the two powered wheels the robot will have casters or a scoop to stabilize itself. The advantage of the casters would be that they are wheels, and therefore they do not require a great force to move but they are less stable than a scoop. The number of casters needs to be taken into consideration. This will determine the robot’s center of gravity. We can consider either one or two caters. One caster will have the center of gravity in the middle of the triangle caused by the 2 back-powered wheels and the front caster. Two caters will cause a center of gravity in the middle of the rectangle between the two back wheels and the 2 front casters. 
The advantage of a scoop is that there would be better stability and the possibility of using the scoop as a false ring edge line to fool other robots. The disadvantage of the scoop would be that it scratches the ring surface and therefore it requires more force to push than casters. Lastly, the scoop may cause a jam with an opposing robot, and stall the robot. 
Finally, a two wheel robot will have only two motors which might cause a disadvantage in the total power and torque available. Furthermore, in the case of a motor failure the robot will turn in circles.  Concluding the two wheel option, the robot will be less robust but will be easily controlled and have a very high degree of maneuverability. 
Four Wheels
The main advantage of having four wheels is that the whole weight of the robot is distributed on driving wheels, making the robot more robust. Having more wheels allows the robot to have better traction and a greater pushing power available to all the wheels. This is an enormous advantage in the case of a muscle competition.  Having four motors will draw more power making the robot stronger. Finally, having four wheels give the robot less maneuverability since all four wheels need to be controlled and powered accordingly to each required action. 
Six Wheels
The 6 wheels configuration will have similar properties to that of the 4 wheels robot, but with more stability, torque, and available force. Having those advantages leads to a lower maneuverability and higher power consumption. 
Tank Threads
The main advantage of the tank threads is the traction which gives a lot of pushing power. Each track requires one motor and there is no need for a gear system. The main disadvantages are that it is difficult to keep the threads on and the large frictional resistance causes a lot of energy wasting. 
Each thread would require two wheels to have a better skid support. Having four wheels will have similar advantages and disadvantages to the traditional four wheels robot. 
Steering 
There are two main steering strategies to consider: the Ackermann steering and differential steering. Usually Ackermann steering is used with 4 wheels and differential is used with 2 wheels. 
Ackermann Steering
The advantage of the Ackermann steering is that it only requires one drive motor and one servo motor. It is popular with 3 wheeled robots and it is useful for high speeds and turning in large areas while fewer components are needed for the power train. The main disadvantage is that it cannot spin around quickly. To completely turn around, the robot must do a U-turn or a 3 point Y turn. The minimum turning radius is a function of the angle of the front wheels and distance between front and rear wheels. Figure 1 shows the Ackermann steering.
 
Figure 1: Ackermann steering 
Differential Steering 
The main advantages of the differential steering are the fast turns and it is the preferred method of steering for sumo-bots. Spinning, moving forward and/or backward does not require much manipulation. Turning or going slightly towards the right (or the left) requires that the motors run at different speeds, which can be easily controlled from a microcontroller. Turning on a radius with differential steering is challenging with autonomous robots and requires knowledge of the relationship between wheels and turning radius. Figure 2 demonstrates the differential steering. 
 
Figure 2: Differential steering 
Motors
Most sumo-bots use PMDC (permanent magnet direct current) motors. Motor speed is proportional to the applied voltage across a motor and the torque is proportional to the current being drawn. For real motors, speed is reduced by current going through them. 
The motor speed can be estimated using the following formula:	
Motor speed: RPM = Kv (V_motor )where? V?_motor  = V_in  -I_in R (voltage of motor terminals,current drawn,internal resistance)
The torque can be estimated using the following:
 Torque = Kt(I_in-I_o) where I_o  is no load current
An important formula is the relationship between torque and speed:
RPM =Kv(V_in-R(I_o  +torque/Kt))
These equations can help determining the motor performance for various loads and applied voltage.
Stall Current
Sumo bots are always pushed to their limit since they are pushing something that does not want to be pushed. Wheel traction, gear reduction and motor torque are all important factors, but not taking stall current into account can burn out a motor, drain batteries or burn out a motor controller. 
As the applied torque on the motor increases, motor will draw more current to counter the applied torque (slows down motor). When the torque is so high that the motor stalls, the robot will be drawing the max current from the batteries, hence the name stall current. A way of estimating the stall current is: 
	I_stall= V_in/R , where Vin is the voltage across motor terminal and R is the internal resistance of the motor. Once we know the stall current, we need to make sure we choose a correctly sized motor controller and know the battery’s peak current capacity. 
Stalled motors will always fail if stalled for a long enough time. Having a robot stalled will generate a lot of heat which will raise the resistance of everything; it could melt wires, and even burn out motors. 
Increasing torque and speed is done simply by increasing the terminal voltage of the motor. Doubling input voltage may double speed and even torque, but the price is much more expensive. If the motor is stalled, there are even more chances to burn the motors out. 
Cooling Motors
Cooling the motors might be useful whenever allowed since this will control their heat and possibly prevent burnouts, stalls, and other possible issues.  
Cooling strategies
One of the cooling strategies could be using a can of compressed air to cool the motors after each match. Another strategy would be to use active fans that would cool the motors while they run. 
Another approach would be to prevent the motors from overheating and this could be done in two ways. One would be to place encoders on the wheels and using the microcontroller verify periodically the voltage obtained and adjusting the motors voltage accordingly. Another alternative would be to design a current limiting mechanism that would limit the motor's possible current. 
Power Transmission Fundamentals
Transmitting power from the motor to the wheels plays the biggest role in speed and pushing power. 
There are 2 design strategies; design around set parts or design around performance. Velocity = (circumference)*(revs/min) = pi*D*N (solving for N could be useful figure of merit for determining motor rating)
Turning on a radius with differential steering
This is trivial for Ackermann steering but challenging for differential steering. Most beginners keep the wheels at same speed, thus only allowing 360 spin and forward/reverse motion. To get a particular turning radius, it is the separation of the wheels and the relative speed ratios that matters. Figure 3 shows an example of how to measure and calculate the turning radius with differential steering. 

 
  
Figure 3: Turning radius 
Pushing force
Pushing force is a function of traction and torque. Thus we need to maximize weight, the coefficient of friction between wheels and the ring which the motor needs to generate max torque that is less than spinning torque. Not only is additional torque wasteful, it actually decreases pushing force.
Batteries (Heart of the Robot)
Since batteries are usually the heaviest component, they should be located at the bottom (lower center of gravity).  The batteries should be placed such that they are easy to replace.  Consider using a separate battery pack for the motors and the electronics. Remember that for any big action, there will be current spikes, this can cause big voltage drops from the battery, and if that voltage drops below 4.5V there is a risk of resetting the microcontroller!
 
Figure 4: Battery 
If you use 2 separate power supplies, you will still need a common ground. The electronics & microcontroller generally have much smaller power demand than the motors. An alternative would be to use smaller battery packs. Some feel that a separate battery pack for the electronics is not justified due to its smaller power consumption relative to the motors. An alternative solution that addresses this complaint is placing 2 battery packs in series and center tapping for the electronics. 
Motor Control Fundamentals
Reversing current for PMDC will reverse rotation. 
 
Figure 5: H-bridge circuit (using switches) 
Of the 16 possibilities only 2 are used; 1001 and 0110 (so closing AD will make you go forward, closing BC will make you go backwards, note polarity on motor). One must be careful of the short circuit condition; it could cause the battery to explode. 
 
Figure 6: H-bridge circuit (Relay control) 
 
Figure 7: Solid state H-bridge (use transistors instead of relays) 

 
 
Figure 8: Integrated circuit based solution (most common in our course) 
Caution: heat sink is required when motors are drawing half or more of current rating. 
Table 1: Wheels motion 
 
There are 9 possibilities (each side can either be forward, backward or off). Pivoting and rotating about an axis are very similar, but pivoting is slightly better at evading and rotating about an axis is a little better for searching. 
Variable Speed Control
You might only want your robot to go at its fastest speed going forward/reverse. You may want the robot to move slower while searching. If you want to move around some given radius and you’re using differential steering, you need to vary the wheel speed. Since the wheel speed is simply a function of applied voltage to the motor, the speed control problem is really a voltage control problem. You can use variable resistors or pulse width modulation (note, PWM is the more popular method in our course).


 
 
  
Figure 9: PWM, Motor time averages the applied voltage 
Final comments about motor speed control 
The controller must be able to meet the voltage/current needs of the motor. Controller needs to handle max current drawn from motor. 




Sensors (eyes of the robot)
 
Figure 10: Sensor (Eyes of the Robot) placement 
For facing straight ahead, if the left detector has a hit and right does not, the robot will turn a little bit to the left. If both of the sensors detect an object, then the object in center of the beam, therefore the robot should go forward. The greatest disadvantage is the limited overall width of the detection range. The sensors facing outwards will increase the detection range but you will lose the center detection range. Crossing beams will maximize the detection width and center but this will cause you to lose the forward projection range. 

 
Figure 11: Example of 360 visions 
Panning sensor: When the panning sensor detects an object, it continues to pan. The microcontroller will record the object range based on the signal strength and the servo position. When a distance reading is at a minimum, then you know that the sensor is pointing directly at the object.  A variant of this approach is the body of the entire robot pans. 
Intelligent response for line detection (assuming rectangular sensor configuration, some advantages over 2 line sensors)






Table 2: Responses of robot towards boundary line detection 
 
Existing robots
 
Figure 12: The Goliath 
The Goliath, shown is Figure 12, is a well-rounded robot that has beaten sumobots 6 times its weight. Its strength comes from its plow like design and its huge wheels that provide massive traction. One unique characteristic of this sumobot is that it is actually longer than the specs; therefore the bot starts the match on its back as shown in the above picture. This robot uses four sharp GP2D15 sensors for tracking and a pair of reflective sensors for edge detection


 
Figure 13: The Bam 
The Bam robots uniqueness comes from not relying on infrared reflective sensors for tracking. Instead, it uses ultrasonic sensors to track its competitors. It is a very small, compact yet efficient design. 
 
Figure 14: Six-Pack 
Six-Pack is a 6 wheel drive mini sumo bot. Like the Goliath, it is also out of the specs when the scoop is fully deployed. Luckily, the scoop is foldable and thus the Six-Pack is a legitimate competitor, which relies heavily on its plow and six motors. 
 
Figure 15: The black widow 
The black widow, shown in Figure 15, is one of the more unique yet quirky robots to grace the sumobot competition. It uses no sensors but also relies on not being seen. Using flat surfaces to deflect infrared light away from its opponents as well as its high maneuverability, the black widow remains elusive during the match. During a battle where both robots are blind, the black widow has a unique advantage as its algorithm doesn’t rely on finding the opponent. It moves in random directions aggressively until it finds its prey. 
Evaluating Alternatives
	The alternative evaluations were done in three steps. The first step was to analyze the needs and decide what is important in each component. Not all components will be fully analyzed since some components are dependent on previously graded and chosen parts. A grading scheme for each need was decided depend how important each category is to each member. The final grade is an average of those grades. Finally each component was analyzed depending on how well it fits the requirements and a final score was obtained.
Once all the components are fully analyzed, 2 full robots will be designed and once again fully analyzed. The best grading robot will be the choice for this project.
Chassis
	When choosing a chassis we have several factors to consider. Since the overall goal of the robot is to push out an opponent out of the ring the importance of a 4 wheel robot is large. To have a good center of mass a low profile chassis is important. To fully and securely attach all the parts to the robot the chassis should allow the user to easily attach parts and therefore should have several screws holes around the chassis. Another important factor is that the chassis should be stable and therefore preferably square. Finally, due to budget limits the price of the chassis needs to be taken into consideration. Table 3 represents the different choices available, their scores at each factor, and finally the overall grade.
Table 3: Chassis evaluation
Chassis	Importance	204x89mm	121x145mm	DFRobot 2WD 
Mobile Platrom	Pololu Round 
Robot Chassis Kit
Accommodate 4 wheels/motors	85	5	5	0	0
Low profile	80	3	3	3	5
Accommodate large breadboard	50	4	5	4	4
Stable (not to tin, not to long)	95	5	3	4	4
Easily attachable parts	90	3	3	5	4
Price	-60	1	1	5	4
Score	 	15.5	14.1	9.7	11
Motor
	The motor evaluations are based mainly on six criteria. The first one is the speed of the motor. The importance of speed is not the greatest however the speed should be still reasonable since the robot should be able to catch up with other robot while attacking and running away from another robot when in defense mode. The torque is a major factor since the torque gives the robot the force to push opponents and win the competition. The gear system is important as well since a good gear system creates a link between the speed and the torque of the motor. Since the voltage and current available is limited the voltage requirement and power consumption are taken into consideration. Finally the price of the motors will affect the final decision and therefore it is included in the evaluation. Table 4 shows the motors evaluation. Wheels will not be evaluated since the choice of the motor will directly affect the choice of the wheels.  
Table 4: Motors evaluation
Motor 	Importance	SolarBotics GM2	SolarBotics GM8	SolarBotics GM6	SolarBotics GM10
Speed	85	3	4	1	5
Torque	90	4	5	3	1
Gears	35	5	4	3	3
Voltage required	60	5	5	5	5
Power consumption	45	3	3	1	4
Price	-60	1	1	5	3
Score	 	11.65	13.05	5.05	9.2
Motor driver
	The motor drivers are analyzed mainly of their power transfer characteristics. The motor drivers need to be able to transfer all the power needed by the motors and therefore their choice is directly dependent on the number and type of motor chosen. It is of particular importance that the motor driver can handle the stall current. Another important characteristic of the motor driver is the number of independent motors it can drive. Finally, the price of the motor driver needs to be taken into account due to the limited overall budget. Table 5 shows the analyzed motor drivers and their results in each category as well as an overall score.  
 
Table 5: Motor driver evaluation
Motor Driver	Importance	SolarBotics L298 
Compact Dual Motor
 Driver Kit	Rogue Robotic Low Cost 
Dual H-Bridge Motor 
Controller 1.1A	Quad half-H-Bridge 
chip SN754410N
 
Max power transfer 	90	5	4	4
Number of motors that can be driven	85	5	5	5
Price	-60	5	4	1
Score	 	5.75	5.45	7.25
Microcontroller
	The choice of the microcontroller is very important since this is the brain of the robot. Some of the consideration while analyzing the microcontroller is the number of inputs and output, the speed of the microcontroller, the number of analog to digital converters, the pulse width modulation ports, number of hardware and software interrupts, and finally the price. Table 6 shows the microcontrollers analyzed the criteria in which they were analyzed their scores in each category, and finally an overall score. 
Table 6: Microcontroller evaluation
Microcontroller	Importance	Solarbotics  K SV-PIC, 
The sumovore 16F877A 
Brainboard add-on Kit	Solarbotics K SV-Atmel, 
The sumovore Atmel M
ega8 Brainboard Add-on Kit	Atmega8 Chip	Atmega328 chip
I/O pins	85	5	4	4	4
Speed	60	5	4	4	5
ADC	90	5	4	4	4
PWM	90	3	4	4	5
Hardware Interrupts	95	3	5	5	5
Software Interrupt 	95	5	5	5	5
Price	-60	5	4	1	2
Score	 	19.05	20.1	21.9	22.8
Distance Sensors
	The choice of the distance sensors depends mainly on three categories: the distance the sensors can detect, the power consumption, and the price. The distance is important since this sensor is the eye of the robot. A large capturing distance can mislead the robot since it will be able to detect objects outside the ring and therefore capture unnecessary readings. A too short capturing distance might not detect the opponents and therefore drive around the ring blindly. From this analysis a detecting distance between 10cm and 80cm is desirable. The power consumption is another factor that can be taken in consideration but with a low importance. The power consumption of any sensor will be much less than any motor and therefore this should not be a major factor. Finally, the price of the sensor needs to be taken into consideration. Table 7 shows the different sensors and the results in each category as well as a final score. 
Table 7: Distance sensors evaluation
Sensors (distance)	Importance	Sharp GP2D12 IR
 Range Sensor	Sharp GP2Y0A02Yk IR
 Range Sensor	Phidgets IR Distance Kit
Distance	70	4	5	4
Power consumption	65	5	5	5
Price	-60	1	3	5
Score	 	5.45	4.95	3.05
 Line sensors
	The choice of line sensors depends mainly on three characteristics. First, the sensor should be usable as a digital component; this characteristic has a very high importance. Then, the power consumption of the sensor needs to be taken into consideration. It is known fact the sensors power consumption will be much lower that the consumption of a motor and therefore this characteristic is not of main importance. Finally, the price of the sensor needs to be taken into account since the budget of the overall robot is limited. Table 8 shows the evaluation of the different types of line sensors. 
Table 8: Line sensors evaluation
Sensors (line)	Importance	OPB606A IR
 sensor	OPB704 IR
 Sensor
Digital 	100	5	5
Power consumption	60	5	4
Price	-60	1	3
Score	 	7.4	5.6
The Alternatives 
Robot 1
Table 9: Robot alternative 1
Component	Description	Individual price	Total Price
Chassis: 	121x145mm	1 x 6.00$         	6.00$
Breadboard: 	ABRA-270	2 x 7.00$       	14.00$
Wheels/Motors: 	GM8 + Solarbotics GWPM wheels	4 x 11.00$   	44.00$
Motor driver:	Quad half-H-Bridge chip SN754410N	2 x 1.00$         	2.00$
Motor bracket:	Mounting bracket	4 x 1.50$   	6.00$
Microcontroller:	Atmega8	1 x 3.00$         	3.00$
Distance sensors:	Sharp GP2D12 IR Range Sensor	5x 12.00$      	60.00$
Contact switch:	SPDT	4 x 1.00$         	4.00$
Line sensor:	OPB606A IR sensor	4 x 2.50$   	10.00$
Battery pack:	6xAA	2 x 16.00$	32.00$
Charger:	Charger	1 x 4.00$         	4.00$
Voltage regulator:	LM78M05	1 x 0.50$	0.50$
Cable:	LPT-ISP cable + header	1 x 5.50$   	5.50$
Total Cost: 		191.00$
The remaining 9$ can be spend on the needed resistors, capacitors, inductors, or any other small electronics. In addition, there could be additional mechanical complexity requiring Plexiglas. A final budget will be determined at implementation time. 
Robot 2
Table 10: Robot alternative 2
Component	Description	Individual price	Total Price
Chassis: 	DFRobot 2WD Mobile Platform	1 x 39$       	39.00$
Breadboard: 	ABRA-270	2 x 6.00$       	12.00$
Wheels/Motors:	Not needed (comes with the chassis)	-----------     	0.00$
Motor bracket:	Not needed (comes with the chassis)	-----------     	0.00$
Motor driver:	Quad half-H-Bridge chip SN754410N	1 x 1$         	1.00$
Microcontroller:	Atmega8 Chip	1 x $3         	3.00$
Distance sensors:	Sharp GP2D12 IR Range Sensor	6 x 12$      	72.00$
Contact switch:	SPDT	4 x 1$       	4.00$
Line sensor: 	OPB606A IR sensor	4 x 2.50$   	10.00$
Battery pack:	6xAA (9V)	2 x 16$	32.00$
Voltage regulator:	LM78M05	1 x 0.50$	0.50$
Charger:	Charger	1 x 4$         	4.00$
Cable:	LPT-ISP cable + header	1 x 5.50$   	5.50$
Total Cost: 		183.00$
The remaining 17$ can be spend on the needed resistors, capacitors, inductors, or any other small electronics. A final budget will be determined at implementation time. 
The choice
Table 11 represents the evaluation of the robots according to the choices of components and those components scores. 
Table 11: Robots evaluation
 	Robot 1	Robot 2
Chassis	15.5	14.1
Wheels/Motor	13.05	13.05
Motor Driver	7.25	7.25
Micro-Controller	21.9	21.9
Distance Sensor	5.45	5.45
Line Sensor	7.4	7.4
Total	70.55	69.15

Robot 1 has been chosen because of its higher score. It will include a 121x145mm chassis because it has enough room to fit all the chosen components. The breadboard choice was limited by the choice of the chassis and therefore two ABRA-270 breadboards will be used. The motor choice was based to maximize torque while keeping a proper traction ratio to the wheels. Maximizing on torque and the traction might burn the motors because of a wrong ratio, although it is much more dangerous to have a higher traction ratio then torque ratio. In the event that the traction is too high and our torque is not high enough to get the robot to move, you can burn the motors and possibly damage other components in your circuit. Two H-bridges will be used to drive the four chosen motors. This is due to the maximum power transfer on the H-bridge, which can satisfy only two motors at a time. The reason behind the H-Bridges is to isolate the microcontroller from the motors since both components work at different voltages. The Atmega8 chip has been selected as the microcontroller due to the familiarity as well as for its performance and specification qualities. The distance sensors used will be the sharp GP2D12. Those sensors have an operating region from 10 to 80cm. The OPB606A IR sensors will be used as the line sensors allowing the robot to recognize the ring edges while never crossing them. Lastly, there will be four contact sensors, two in the front and two in the back, which will enable the robot to know the moment it has contact with an opponent 
Once the robot has been constructed, a reflective layer will be added which will allow the robot to be invisible to the opponent’s sensors. The signal reflected back towards the opposing robots due to the reflective layer will confuse the opponent’s robot and make it believe that it is simply in the ring and still trying to detect an opponent. 
Block Diagram
 
Figure 16: Block diagram
The block diagram, shown in Figure 16, is the simplified version of what the robot must do. The schematic is based off this design. We may consider this to be a black box with multiple inputs and multiple outputs. The inputs are the infrared, line and contact sensors, as well as the reset button. The Atmega8 is the brains of the robot. It takes the inputs and transfers the signal to its output components. From the Atmega8, we have two H-bridges. The H-bridge will allow our robot to move forward and backwards. We may also think of the H-bridge as the switch which relays the signal from the inputs to the motors. Finally, the motors are connected to the H-bridge. Each H-bridge will control two of the motors. 
Inputs and Outputs
Inputs
The main priority input will be the line sensors. Since the robot cannot cross the line at any time it needs to stop as soon as the line is detected. Since there is a possibility of dirt of the ring the readings from this sensor will be done 3 times and the best of 3 will “win” (line exists or no line exists).
The second priority will be the front and back sensors. There will be two sensors in the front, one on the left and one on the right and the exact same setup in the back. In fact, the robot doesn’t really have a front or back, i.e. the robot looks the same from either view point. This is exploited in the algorithm. The Tautologizer will never have to make an angle more than 90 to attack an opponent. Since the sensor cannot detect anything closer than 10cm the robot will depend on a contact switch to confirm the presence of a robot. 
Outputs
The motors will be controlled using the PWM signals available on the Atmega8. PWM will be used in order to not put full power to the motors and waste battery power when trying to find another robot. Full power will only be applied when a robot is detected in front at a distance of 15cm or less.
When the robot knows he is pushing an opponent and it has reach the ring edge (black tape) it can conclude that the opponent has been successfully pushed out of the ring and therefore the robot can celebrate. The celebration will be done using a flickering LED for 10 seconds; however the robot will still be in search and “destroy” mode.  
Software Flowchart
 
Figure 17: Software flowchart
Figure 17 shows the software flowchart. Once the robot is placed in the ring and the robots are given the start command, there must be a delay of 5 seconds. The robot will have an algorithm in which it will obtain data throughout battles. Before the victory condition can be achieved, the robot will move forward. While moving the sensors will try to detect the opponents while making sure that the robot never leaves the ring, this will be done with the use of the line sensors. Another sensor, pointed slightly up will determine if the object in front is the tower or an opponent. If an opponent has been detected and confirmed the motor power is increased in order to push the opponent out of the ring. If the robot has detected a boundary of the ring, the robot will move randomly to get away from it. The reason the robot moves randomly is to avoid a deadlock, and not to have a predetermined path. Once the robot has enough data gathered to determine a win it will celebrate by flickering an LED while remaining fully active and within the ring. 
 
Work Breakdown Structure
Table 12: Work breakdown, Tentative Project Schedule

Task	People Involved	Person In Charge	 Start Date (mm/dd/yy)	Due Date (mm/dd/yy)
Flow Chart	Grzegorz, Oscar	Oscar	09/01/2012	27/01/2012
Block Diagram	Grzegorz, Oscar	Oscar	09/01/2012	27/01/2012
Tech 1 Schematic	Michael	Michael	09/01/2012	27/01/2012
Documentation (Assignment 1)	Alexander	Alexander	16/01/2012	20/01/2012
Tech 1 Defense Meeting	Group	Grzegorz	19/01/2012	19/01/2012
Tech 1 Defense Meeting	Group	Grzegorz	23/01/2012	23/01/2012
Hardware Implementation	Michael, Alexander	Michael	23/01/2012	27/01/2012
Hardware Testing	Group	Grzegorz	23/01/2012	02/02/2012
Documentation (Assignment 2)	Alexander	Alexander	20/01/2012	27/01/2012
Software 	Grzegorz, Oscar	Oscar	16/01/2012	27/01/2012
Group Meeting	Group	Grzegorz	30/01/2012	30/01/2012
Documentation (Assignment 3)	Alexander, Michael	Alexander	30/01/2012	03/02/2012
Tech 1 Demo	Group	Grzegorz	03/02/2012	03/02/2012
Block Diagram	Grzegorz, Oscar	Grzegorz	07/02/2012	10/02/2012
Tech 2 Schematic	Michael	Michael	07/02/2012	10/02/2012
Software 	Grzegorz, Oscar	Oscar	07/02/2012	02/03/2012
Flow Chart	Oscar	Oscar	04/02/2012	17/02/2012
Defining Robot Parameters 	Group	Grzegorz	13/02/2012	18/02/2012
Tech 2 Defense Meeting	Group	Grzegorz	10/02/2012	10/02/2012
Hardware Implementation	Michael, Alexander	Michael	13/02/2012	17/02/2012
Hardware Testing	Group	Grzegorz	13/02/2012	29/02/2012
Alternative Robots	Grzegorz, Alexander	Grzegorz	20/02/2012	27/02/2012
Design Robot Schematic	Michael	Michael	01/03/2012	08/03/2012
Robot Flowchart	Oscar	Oscar	03/03/2012	08/03/2012
Proposal Presentation 	Group	Group	07/03/2012	21/03/2012
Robot Defense	Group	Grzegorz	09/03/2012	09/03/2012
Hardware Implementation	Micheal, Alexander	Michael	16/03/2012	18/03/2012
Software 	Grzegorz, Oscar	Oscar	16/03/2012	24/03/2012
Testing and User Documentation	Group	Alexander	19/03/2012	26/03/2012
Robot Trials	Group	Group	26/03/2012	26/03/2012
Robot Modifications	Grzegorz, Oscar	Oscar	26/03/2012	11/04/2012
Documentation (Assignment 4)	Alexander	Alexander	06/02/2012	02/03/2012
Documentation (Assignment 5)	Alexander	Alexander	05/03/2012	30/03/2012
Full Design Report	Group	Alexander	04/04/2012	04/04/2012
Robot Competition	Group	Group 	10/04/2012	12/04/2012

 
Figure 18: Gann Chart
 
Schematic
 
Figure 19: Schematic
 
Description of the Schematic
	Our goal is to design an autonomous robot that will remain in the ring while pushing other hostile robots out of the ring. Before one can implement the software, the hardware must come first. A robots complexity is an emergent property; far greater than the sum of its parts therefore there must be synchronization between the parts and correct circuit topology. Our robot can be thought of as a black box that takes environmental information, processes it and then responds through motion. The Atmega8 is the brains of our robots and is responsible for processing information from our line, contact and IR sensors. Once the atmega8 analyzes the information, it will send an output to an H-Bridge which will then said the appropriate signal to the motor. Simply changing the voltage across the motor as well as the duty cycle at the enable will allow us to control the speed of our robot and its direction. The full schematic can be seen in Figure 19.
Batteries
If the Atmega8 is the brains of our robot, then surly the batteries are the heart.  We will be using two 6xAA NiMH battery packs (2500mA/h). Because of the current demand from the motors, we used one battery pack to drive the motors and another for the electronics. This will prevent the Atmega8 from resetting when it is not supposed to and protect the electronics from the damaging current spikes created by the motors.
Double pole Single Throw switch
The number of poles tells you how many different current path the switch can control. The type of throw can either be single which is on/off or it could be double which is an alternative current path. The reason for this particular switch is so we can turn off the power to both the electronics and the motors at the same time. 
Voltage regulator
The LM7805 Voltage regulators convert a voltage applied to their input into a fixed and lower voltage. Electronics can be quite sensitive to spikes in their power supply; they absolutely demand a stable power supply. Our regulator will take 7.2Volts and convert them to 5V. The regulator serves to eliminate noise as well as prevent power dips. Nevertheless, one should use decoupling capacitors since the regulator could have trouble meeting the demands when there is a lot of electronic activity. 
Analog Infrared sensors
The eyes of our robot; The GP2D12 sensors transmit infrared waves, and the will respond with an output voltage if it the wave returns to the receiver. The output voltage is a function of distance. Even though the microprocessor processes information digitally, with the aid of an analog digital converter, it is possible to process analog information digitally, with up to 10 bit accuracy.  A decoupling capacitor is placed between the GND and the VCC to accommodate the spikes due to the pulsating nature of the sensor.  The AREF of the Atmega8 should be designed to accommodate the highest output voltage possible from the sensor 
Line sensors
The OPB606A can be used as a digital or an analog sensor. The IR LED will be shining ‘light’ onto the arena. When the arena is white, the light is reflecting into the base of a NPN phototransistor which will put it in the saturation mode of operation. When the IR LED shines ‘light’ onto a black line, the transistor will be in the cut off region since no light will be reflected. We selected the resistor in series with the LED, the pull up resistor at the collector and the distance of the sensor such that we would have high logic if the line sensor detects the black line. There is one line sensor in the front and one in the back. 
 
Push Button
The Push Button is required for external resets. The resistor is placed in series to prevent shorts and deal with possible current spikes that might be caused by de-bounces. 
Atmega8
The brains of our robot; it provides 2 external interrupt pins, 6 ADC pins, programmable serial USART, 3 PWM channels, Master/Slave SPI serial interface and 23 I/O pins. The Atmega8 is a cheap yet solution for our autonomous robot. The Atmega8 is basically a programmable logic gate. 
H-Bridge
The SN754410 allows for motors to be controlled by microcontrollers. One needs to select a motor driver that can handle the current needs of the motor. We chose 2 H-bridges based on the fact that we chose 4 motors and their stall currents are in the 700mA range. Since the H-Bridge only has 1.1A driving capability per motor, we needed to have 2 H-bridges. The H-bridge uses transistor switches in a clever way that allows one to change the polarity across the motor without creating a short circuit. Speed control will be done via PWM at the enable port. 
Motors
The Gear Motor 8 - 143:1 Offset Shaft is the muscles of our robot. If 2 robots collide, the one with the most torque, best gear train and best traction will win provided that they have the power supply and motor drivers that can support the power demands of the motor. Speed of the motor is decided by the voltage across it, the rotation of the shaft is decided by the polarity and the amount of torque is current driven.
Resistors
Resistors allow us to control the amount of current going through a branch and the voltage at a node. 
Capacitors
Decoupling capacitors are low pass filters that prevent high frequency spikes from damaging integrated circuits. Capacitors also are resistant to voltage change and thus can provide temporary energy stored in its electromagnetic field for small power dips.  
Inductors
Used in combination with a capacitor to form a low pass network; this network is connected to the AVCC pin. The reason for the AVCC pin is that there is a lot of noise coming from the digital pins due to their switching action. The atmega8 was cleverly designed to support a separate power supply to its analog pins, this will allow for greater accuracy when doing analog to digital conversion. Inductors can also store energy within their magnetic field and can temporarily substitute for a current source.
ISP
Used for loading the software onto the Atmega8. The Atmega8 is compatible with the serial device programmer PonyProg.
Bill of Materials/Budget/labour
Table 13: Bill of Materials
#	Item	Quantity
Requested   Received   Backorder	Unit price	Total	Comments
1	Chassis 121x145mm	1	 	 	6.00	 6.00	 
2	Breadboard ABRA-270	2	 	 	 7.00	 14.00	 
3	Motor GM8	4	 	 	7.00	 28.00	 
4	Wheels Solarbotics GWPM	2	 	 	 8.00	 16.00	
5	Motor driver SN754410N	2	 	 	 1.00	 2.00	
6	Motor bracket	4	 	 	 1.50	 6.00	
7	GP2D12	5	 	 	 12.00	 60.00	 
8	Contact switch	4	 	 	 1.00	 4.00	
9	Line sensor OPB606A	4	 	 	 2.50	10.00	 
 10	Battery pack	2 	 	 	 16.00	 32.00	 
11	Charger	1			4.00	4.00	
 	Order processing fee	1	1	0	3.00	3.00	 
Total for the order:	 185.00	 
In addition, the Plexiglas was 22$. We have 14 capacitors and 7 resistors costing up to 5.25$. the final total is 195.25$. All of us agreed to put in about 10 hours a week at a salary of 7$ per hour. 15weeks *10 hours/week *7$/hour*4 people = 4200$ in labour. 
 Team Dynamics 
Member’s Roles & Responsibility
Grzegorz Gut
Grzegorz is the team leader of the group. As team leader, he has the responsibility to provide constructive criticism and feedback on his team members designs. He is to challenge his team members design in such a way that will prepare them for the defense of the schematic and software. His main roll will be software design, implementation, and testing while managing the progress of the overall project. 
Alexander St-Louis
Alexander is one of the hardware designers. As a hardware designer, he must come up with a schematic with certain specifications. Once the schematic has been approved, his role is to construct the circuit and make sure it follows the design specifications. He must inform the software design team if modifications to the software are required. He is also responsible for the group’s documentation, and must keep records of what the group has done. 
Oscar Tsui
Oscar is one of the software designers. As a software designer, he must come up with the appropriate algorithm in which will accommodate the client’s specifications. Once the algorithm is completed, he will work alongside the team leader in designing the software and implementation. He will also aid in documentation to ensure that deadlines are respected. 
Michael Goodman
Michael is one of the hardware designers. As a hardware designer, he must come up with a schematic with certain specifications requested by the client. He will come up with an appropriate list of materials in order to construct the circuit. He will provide the necessary calculations to obtain the required materials for the circuit. He will defend and justify the schematic such that he will obtain the necessary materials in order to construct the circuit. He will implement the circuit design and debug the circuit to ensure that it works to the desired specifications. 
Team Task distribution
The two following Vann diagram shows the task distribution between the members of the team. The two diagrams do not exclusively denote the team members who will be working on the particular task but the responsible team member.  
Figure 20 shows the member distribution for different tasks in research and development. It can be noted that Oscar is responsible for the software development, Michael is responsible for the Hardware development, and Grzegorz is overseeing the progress of research and development.
Figure 21 shows the quality assurance and the responsible team members for each category. It can be seen that Oscar is responsible for software testing, Michael is responsible for hardware testing, Alexander is responsible for documentation, and Grzegorz is overseeing the overall progress of the project. 
 
Figure 20: Research and development
 
Figure 21: Quality assurance
Working agreement
The following is the 2BV~2B working agreement. 
Group Organization
	Regularly check email and maintain frequent contact with team members
	Schedule a meeting after every class, and before every meeting with the course coordinator  
	Respecting deadlines/meetings and informing the group of any possible absences
Meeting Format
	Focus on the task at hand during the meetings and avoid going off topic
	Respecting deadlines for assignments
	Documentation of possible solutions or of the group discussions
	Any major decision will be discussed and agreed upon by the whole group
	Make sure each member is informed about the deadlines
	Completing tasks before the deadline so that the group may review and provide feedback
General Guidelines
	Address and resolve issues as they arise 
	Fair distribution of the tasks
	Be open to new ideas and provide positive feedback or possible alternatives 
	The team agreement may be reviewed and modified at any time
	Arrive to the scheduled meetings and be properly prepared for the discussion
	Get group members to actively participate in discussion
How it panned out
Over the course of the project, the team had their issues like any other team, but the group put in the necessary effort in order to achieve team harmony and obtain the appropriate results while following the working agreement, and properly engaging each other when considering ideas for the final design. 
Troubleshooting effort between trials and competition
Before the trials, our double pole double throw switch was not working properly. The DMM indicated that while the electronics were receiving the correct voltage, the h-bridges were not. Under the pressure of the trials, it was proposed to remove the switch and just connect the batteries manually. 
During the robot trials, our robot conformed to most of design specifications. Our robot was able to:
	Move from the initial position
	Detected the boundary of the ring
	Detected and found the opponent
	Tracked the opponent
	Engaged and attacked the opposing robot
	Won against an opposing sumo robot
Unfortunately our robot didn’t have a 5 second delay, and wasn’t able to evade its opponent. Another issue came up during the robot trials. When our robot was lifted from the ground, and placed back in the ring, the Tautologizer malfunctioned and started to continuously spin until a team member disabled the power supply. After inspecting the robot, our H-bridge motor driver had cracked. There are many possible reasons as to why the circuit malfunctioned. We can consider both the hardware and software scenarios. From a software point of view, there might have been a miscalculation and didn’t take into account a voltage spike. From a hardware point of view, when the robot was being placed back inside the ring to test its performance, a wire may have popped out and that may have led to a short circuit. A short circuit can have devastating effects on a circuit. It has the potential to damage circuit components. 
There were several things that were taken into account after the robot trials. From the software point of view, a delay of 5 seconds was implemented to halt any activity or action once the power supply has been turned on. This is one of the functional requirements in which needed to be satisfied for the customer. The algorithm was also modified to incorporate a function in which the robot may evade and attack the opposing robot. 
From the hardware point of view, the robot was reconstructed and the connections were remade on the circuits. This is to help avoid the possibility of wires popping out (and the possibility of a short circuit) over the course of the robot competition. When remaking the robot, there were special measures taken in order to make the robot look more aesthetically pleasing to the eye. By doing this, the robot looks “cleaner” and has the added advantage of making it easier to debug the robot over the course of the robot competition. 
Methodical testing results
Sensors are essentially the eyes of our robot. In order to make sure our robot can satisfy the requirements and be efficient when combating an opposing robot, it is necessary to determine each sensors range of operation. The following is the experimental results of all our distance sensors. The polynomial obtained from the experimental results 
Sensor 1                                     		
Table 14: Results for Sensor 1
Distance (cm)	Away	Towards	Away	Towards	Average
10	2.52	2.53	2.51	2.53	2.5225
12.5	2.09	2.1	2.09	2.1	2.095
15	1.79	1.78	1.75	1.8	1.78
17.5	1.56	1.57	1.57	1.58	1.57
20	1.38	1.38	1.38	1.38	1.38
22.5	1.21	1.22	1.22	1.23	1.22
25	1.09	1.08	1.09	1.09	1.0875
30	0.82	0.82	0.82	0.82	0.82
45	0.38	0.38	0.38	0.38	0.38
60	0.19	0.19	0.19	0.19	0.19
75	0.15	0.15	0.16	0.17	0.1575

 
Graph 1: Relationship between voltage at sensor’s output and distance of detected object
Sensor2
Table 15: Results for Sensor 2
Distance (cm)	Away	Towards	Away	Towards	Average
5	1.63	-	-	-	-
10	2.44	2.45	2.45	2.45	2.4475
12.5	2	2	2	2	2
15	1.71	1.7	1.7	1.7	1.7025
17.5	1.5	1.48	1.49	1.49	1.49
20	1.32	1.3	1.32	1.31	1.3125
22.5	1.16	1.16	1.16	1.16	1.16
25	1.05	1.05	1.05	1.05	1.05
30	0.86	0.86	0.86	0.86	0.86
45	0.51	0.53	0.53	0.51	0.52
60	0.4	0.41	0.41	0.41	0.4075
75	0.36	0.37	0.37	0.37	0.3675
 
 
Graph 2: Relationship between voltage at sensor’s output and distance of detected object
Sensor 3
Table 16: Results for Sensor 3
Distance (cm)	Away	Towards	Away	Towards	Average
5	-	-	-	-	-
10	2.42	2.4	2.41	2.42	2.4125
12.5	2	1.99	1.96	2	1.9875
15	1.67	1.67	1.68	1.68	1.675
17.5	1.45	1.46	1.45	1.45	1.4525
20	1.26	1.26	1.26	1.26	1.26
22.5	1.09	1.09	1.11	1.09	1.095
25	0.96	0.96	0.94	0.95	0.9525
30	0.69	0.69	0.69	0.69	0.69
45	0.27	0.28	0.27	0.27	0.2725
60	0.12	0.12	0.12	0.13	0.1225
75	0.081	0.081	0.081	0.081	0.081

 
Graph 3: Relationship between voltage at sensor’s output and distance of detected object
Sensor 4
Table 17: Results for Sensor 4
Distance (cm)	Away	Towards	Away	Towards	Average
5	-	-	-	-	-
10	2.52	2.51	2.5	2.51	2.51
12.5	2.08	2.06	2.1	2.06	2.08
15	1.75	1.75	1.75	1.75	1.75
17.5	1.52	1.54	1.51	1.53	1.523333
20	1.33	1.33	1.33	1.34	1.33
22.5	1.17	1.17	1.18	1.17	1.173333
25	1.05	1.06	1.06	1.05	1.056667
30	0.83	0.81	0.81	0.81	0.816667
45	0.38	0.37	0.36	0.36	0.37
60	0.16	0.16	0.16	0.17	0.16
75	0.066	0.066	0.08	0.1	0.070667

 
Graph 4: Relationship between voltage at sensor’s output and distance of detected object
Sensor 5
Table 18: Results for Sensor 5
Distance (cm)	Away	Towards	Away	Towards	Average
5	-	-	-	-	-
10	2.41	2.4	2.4	2.4	2.4025
12.5	2	1.98	1.98	2	1.99
15	1.68	1.69	1.67	1.69	1.6825
17.5	1.47	1.47	1.47	1.47	1.47
20	1.3	1.3	1.28	1.3	1.295
22.5	1.14	1.13	1.13	1.14	1.135
25	1	1.01	1	1.01	1.005
30	0.77	0.78	0.76	0.78	0.7725
45	0.34	0.34	0.34	0.34	0.34
60	0.16	0.16	0.16	0.17	0.1625
75	0.1	0.1	0.1	0.1	0.1

 
Graph 5: Relationship between voltage at sensor’s output and distance of detected object
Proposed Design
Over the course of the semester, the robot schematic has been constantly changing in order to be as efficient and cost effective as possible. Table 19 is the final bill of materials for the Tautologizer robot. 

Table 19: Final Bill of Materials
#	Item	Quantity
Requested Received Backorder	Unit price	Total	Comments
1	Chassis 121x145mm	1	 	 	6	6	 
2	Breadboard ABRA-270	2	 	 	7	14	 
3	Motor GM8	4	 	 	7	28	 
4	Wheels Solarbotics GWPM wheels	2	 	 	8	16	 
5	Motor driver SN754410N	2	 	 	1	2	H-Bridge
6	Brackets	10	 	 	0.25	2.5	 
7	GP2D12	5	 	 	12	60	Distance Sensor
8	Contact switch	4	 	 	1	4	 
9	Line sensor OPB606A	4	 	 	2.5	10	 
10	Battery pack	2 	 	 	16	32	 
11	Charger	1	 	 	4	4	 
12	Resistors 100k, 1/4 watt 	2	 	 	0.25	0.5	 
13	Resistors 220, 1/4 watt	4	 	 	0.25	1	 
14	Resistors 10k, 1/4 watt	7	 	 	0.25	1.75	 
15	Resistors 330, 1/4 watt	1	 	 	0.25	0.25	 
16	Resistors 150, 1/4 watt	1	 	 	0.25	0.25	 
17	AM104 Ceramic Disc Capacitor 0.1uf 50V	13	 	 	0.25	3.25	 
18	AM331 Ceramic Disc Capacitor 0.33uf 50V	1	 	 	0.25	0.25	 
19	Inductor 10uH	1	 	 	0.25	0.25	 
20	Large Spring	1	 	 	1	1	 
21	7805	1	 	 	0.5	0.5	Voltage regulator
22	Atmega8L-8PU-ND	1	 	 	3	3	 
23	Switch	1	 	 	1	1	 
24	Green Led 3mm	1	 	 	0.25	0.25	 
25	Push Button	1	 	 	0.36	0.36	 
26	Electrolytic Capacitor 1000 uF	1	 	 	0.25	0.25	 
37	Electrolytic Capacitor 4700 uF	1	 	 	0.25	0.25	 
Total for the order:	 	192.61
The final design of the robot changed once we tested our robot. We noticed that it was difficult to fit all of the components with the restrictions of the chassis. We had bought extra distance sensors as well as extra line sensors. We coordinated with another team in which needed our extra parts. Therefore a trade agreement was made and we sold our extra parts to group 10. The trade agreement can be seen in Figure 22. An official document signifying that the trade was made between both team leaders. This reduces out total cost of the robot. Our final cost without additional mechanical construction of the robot is 175.61$. We added 22$ of Plexiglas for a final total of 197.61$
FINAL ROBOT COST: 197.61$
 
Figure 22: Trade agreement
Lessons learned
What did you learn and how would you do it better
Our group learned a great deal of technical knowledge, a lot about each other and what it means to be part of a team. There are a lot of transferable skills when working with sumobots, a big one is being experienced with a microprocessor. Our group is confident that given even a different microprocessor other than the atmega8, we could easily implement an intelligent circuit and program it effectively. There is also the project management side and the difficulties of coordinating and communicating a new team under tremendous pressure. At the end of it all, everyone in our group is more confident in their ability and is less hesitant to tackle complex open ended problems.   Some things we could have done better on the tech side was start modeling our final robot earlier. It was only when we received the parts that our robot was beginning to take shape. If we had used google sketch earlier or attempted to buy our robot parts, there probably would have been a lot less stress during the trial and we would have been much closer to completion. In general, we are proud of our work and while there is always room for improvements, there were no major shortcomings in our performance so far. As a team there were many things done well but there were things that could have been done better. Many of the group’s problems could have been solved with better communication, which is an essential skill for any future engineer. 
	Impact of engineering
There is an old joke that doctors kill people one at a time while engineers kill entire societies. While of course this joke is quite cynical, there is truth about how far reaching the decisions of engineers have on society and nature. 
One of the most dramatic turning points in history in terms of social dynamic and environmental impact would be the industrial revolution, in which engineers played a pivotal role. What followed were weaker families, a greater divorce rate and an increasing gap between the poor and the affluent. In addition, those factories that produced the goods to be consumed by North American consumerism were also polluting the air and water. 
Another example is the controversial practice of transgenic and gene engineering. By using plasmid vectors to introduced DNA that codes for a particular protein, one can improve the attributes of various products. For example, one solution for picking tomatoes without bruising them was genetically altering them so that their skin is tougher. Genetic engineering has already been used to improve harvests and to fatten up livestock, but many are concerned about the repercussions of such new and not fully understood practices. 
Surely engineers can have a negative influence on society and nature, but they have also been responsible for many of the conveniences and innovations that we take for granted. Essentially, anything that is not found in nature has to be designed, and the designer is usually an engineer. There have been engineering improvements in transport, communication, health technologies, household appliance etc… which affect all aspects of life. 
With all this power comes a great responsibility. It is important for engineers to be leaders and help educate society while designing for the greater good. No longer can the engineer simply design a product for profit, an engineer must always be mindful of the greater social context that he or she is a part of. 
Conclusion
	The Tautologizer is made to be intelligent, strong, and stealth while keeping the problem statement in mind. In order to better detect the opponents, the robot will have a distance infrared sensor to determine their position. The robots intelligence will stem from its simple, yet effective algorithm. Full power to the motors will only be delivered when the front contact switch is enabled. The line sensors will be located under the chassis in order for the robot to detect the boundary of the ring, and to respect the problem statement. 
	We believe that our robot will have the advantage in terms of power, due to the extra motors, and our four wheel design. Also our stealth will aid in confusing the opposing robots and hence allowing us to gain the advantage and push them out of the ring.  









CHAPTER 2: Technical Manual 


 
About this Manual
Introduction
This technical manual will provide the general description and project overview of the hardware considerations, basic operation, and maintenance of the Tautologizer robot. 
Scope and Purpose
The manual provides the following:
An overview of the electrical and mechanical hardware of the robot
The general description of the basic operations of the robot
The instructions and operation of the equipment and robot
Targeted Audience 
This manual is designed and developed for the users who are required to operate and perform the maintenance of the robot. This manual will aid the operators of any level to fully operate, understand and maintain the Tautologizer robot. 
Organization of this manual
About this manual
This section gives a brief overview of what this manual’s scope, targeted audience, and organization of this document. 
Introduction of the Tautologizer
This section provides some of the attributes and purpose of the robot. This includes a complete circuit of the robot. 
Technical Manual and its components
Gives a complete description of the components used through the construction of the Tautologizer.
Construction instructions
This section outlines the tests required on some components before the construction of the robot, along with a set of instructions for building the robot. 
Block Diagram, Software Algorithm, and Schematic
This section shows the all the diagrams and schematic needed for a proper construction of the robot. 
Instructions for uploading the software to the Robot 
This section lists a set of instructions on how to upload the robot program to the Atmega8 microcontroller. 
Introduction of the Tautologizer
The Tautologizer is an autonomous robot powered by two battery packs. The robot is meant to be intelligent and not rely on brute force (i.e. algorithm and electrical circuitry has more incentive than weight and force).
The target users for the Tautologizer robot are sumobot competitors. A sumobot competition is an event in which two opposing robots are placed in a ring, locate their opponent, and push them out of the ring. 
In order to construct the robot the user has to have the basic understanding of circuits and mechanics. There is a software component in which one must follow the set of instructions to upload the software to the robot. The software can be seen as the brain of the robot which will control its every move. 
Tautologizer Overview 
The next 5 figures are pictures of the Tautologizer robot. Figure 23 and 24 show the front and back of the robot. The two picture look alike since the Tautologizer is symmetrical in front and back. Figure 25 shows the side of the robot. Figure 26 shows the top of the robot, and finally, Figure 27 shows the bottom of the Tautologizer.
 
Figure 23: Front view
 
Figure 24: Back view
 
Figure 25: Side view
 
Figure 26: Top view
 
Figure 27: Bottom view 
Operating ranges of the circuit components
The Effective range of the distance sensor is from 10-80 cm. The LED pulse cycle duration lasts about 32ms. The average current consumption of the sensor is approximately 33 mA. 
The reflective object sensor has a forward region voltage of 1.7 V at 20 mA. This is important for designing the resistor that is in series with the LED. 
The contact sensor has a switch rating of 3A at 30 V DC or 125 V AC. 
The motor driver has an output current of 1 A (peak 1.1 A). The VCC1 operates from a range of 4.5-5.5 V. VCC2 operates at a range of 4.5-36 V.
The microcontroller atmega8 has an operating voltage of 4.5-5.5 V. 
Technical Definition of the Components
This section describes all the components used to fully construct the Tautologizer.
ATMEGA8L-8PU-ND
The atmega8 is a low power CMOS 8-bit microcontroller based on the AVR RISC architecture. This microcontroller has multiple inputs and multiple outputs. The microcontroller is the brain of the robot. It takes the implemented program (in Hex) and processes the appropriate actions when necessary. The atmega8 has 28 pins that are represented by inputs and outputs which may be digital or analog.
DB25 Male ISP Cable and Header
The DB25 male ISP cable is a 25 pin socket. It is used to transfer the written software (in Hex) from computer though the PonyProg software to the ATmega8 microcontroller.
Chassis
The chassis is the base frame of the robot. The chassis size and form limits the options one can implement in terms of design. 
Green LED LTL5H3 Series
The green LED is a semiconductor light source which has a forward voltage in the range of 2.1-2.6 volts.
R1/4-220: 1/4 Watt- 220 Ohm Resistor
 This resistor is designed such that the LED had a decent luminous intensity, but a high enough resistance such that we limit the current to 30mA. Anything above that current can damage the LED. 
LM7805CT-ND
The LM7805CT-ND is a voltage regulator which transforms the input voltage from the batteries to a stable 5V voltage. 
CD224 Ceramic Disc Capacitor .1uf 50V
This is a polar sensitive capacitor which is needed to suppress high frequency noise and short power dips.  
CM334 Ceramic Monolithic Radial Capacitor .33uf
This polar sensitive capacitor is needed in order to minimize the voltage fluctuations on the breadboard.
Breadboard ABRA - 270
The ABRA - 270 is a breadboard which is the construction base for electronic circuits. 
RS232 Cable
The RS232 is a serial cable in which connects to the MAX232 driver/receiver. 
MAX232 
The MAX232 is a dual serial driver/receiver. It’s an integrated circuit in which converts signals from an RS-232 serial port to signals suitable for use in TTL compatible digital logic circuits.
GP2D12
This analog infrared sensor detects an object between 10cm and 80 cm in distance. 
SS-3GLPT
This is a contact sensor in which detects physical contact with an object or surface.
Motor GM8
The GM8 is a gear motor in which the complete motive forces system consisting of an electrical motor and a reducing gear train. The motor is the pushing force of the robot.  
Solarbotics GWPM Wheels
The wheels are circular objects which enable the robot to move over the ground. The size of the wheel increases the traction: the action of drawing or pulling the robot over the surface. 
SN754410N
The SN754410N is a motor driver which governs the performance of the electric motor. The motor driver controls the starting and stopping of the motor, selecting the direction of motion, regulates the torque, as well as protects against an overload. 
Motor Bracket
The motor brackets are used to connect the motors to the chassis.
Contact Switch
A contact switch is a type of sensor which detects physical contact with an object or a surface. 
OPB606A
This is a line sensor. The line sensor is used to determine the boundaries of the ring. 
Battery Pack
The battery pack is the independent power supply of the robot which consists of 12 AA batteries.
Charger
Due to the amount of usage of the battery pack, a charger is required in order to recharge the batteries in between testing and performance trials. 
Instructions for constructing the robot 
The following are detailed instructions on how to fully construct the Tautologizer robot.
Before robot construction
There are several things that need to be done before the construction of the robot. 
Sensor testing
It is important to test all of the robot sensors: distance sensors, line sensors, and contact sensors. Each sensor has a range of acceptable values and therefore it is important to obtain all those values and calibrate each sensor individually. 
Testing the GP2D12 distance sensors
	Construct a circuit which consists of the voltage regulator with capacitors (optional)
	Connect the power supply to the circuit
	Power the sensors with the 5V from the voltage regulator and the ground
	Place an object at 80cm from the sensor and obtain the output voltage
	Move the object 5cm towards the sensor and record the voltage
	Repeat the above step until a 10cm distance from the sensor
	Repeat the above steps with the object moving away from the sensor
NOTE: A typical voltage versus distance to reflective object characteristic curve is depicted in figure 28. 
 
Figure 28: Output voltage vs. distance characteristic 
Testing the contact sensors
	Connect the contact sensor wires to the circuit
	Insert a pull-up resistor at the normally opened part of the contact sensor
	With the aid of a DMM measure the open switch voltage
	Repeat the above step with the switch closed
Note: You should obtain a 5 V at normally opened conditions and 0 V at normally closed conditions
Testing the OPB606A line sensors
	Start by placing black tape on a white surface
	Connect the line sensor to circuit, and add a pull-up resistor to the collector end of the npn phototransistor
	Add the power supply to the circuit: Place the high at the collector (after the pull up resistor) and anode end of the diode, while also grounding the emitter terminal as well as the cathode. 
If the line sensor detects a white surface, then the phototransistor will reflect the “light” and lower the voltage at the collector. If the line sensor detects the black line, the light will be absorbed, and the phototransistor will act as an open circuit. The voltage for the black region must be greater than 3V, in contrast, the white region voltage levels must be less than 1 V. Figure 29 shows the voltage characteristics on this sensor dependently on the distance and surface reflection.
 
Figure 29: Output vs. distance 
Circuit building
Once all the components are acquired and tested, the user may start building the circuit. 
Steps to constructing the initial circuit
	Start by placing the two breadboards side by side such that the two breadboards form a square. There are grooves which will keep the breadboards together
	Place the components onto the breadboard (try to optimize the positioning due to space limitations)
	Establish the common ground between the breadboards
	Start connecting the components as described in the schematic in Figure 33.
	Figure 30 gives the builder an idea of how the building block circuit should look like. This circuit (along with the chassis) is the frame of the rest of the robot. 
 
Figure 30: Building block circuit
Constructing the Rest of the Robot
Steps to add the Battery Pack
	Take the two battery packs and place them side by side (both batteries facing the surface)
	Strap the batteries together with electric tape
	Place the “new” batteries pack underneath the chassis
	Use a long tie-wrap to strap the batteries to the chassis
Mounting the Motors
	Get two pieces of Plexiglas with a width of 3.81cm and length of 12.1cm
	Place 4 screws from the Plexiglas to the chassis
	Once the screws are in position, add a bolt from the chassis (the screw should be out of the chassis) and tighten the bolt until the desired height 
	Connect mounting brackets to the four motors so that they can be attached to the robot
	Place the brackets (with the motors attached) one by one to the Plexiglas and screw the brackets into place. Make sure to strengthen the bottom (where the screw sticks out) with a bolt (repeat for all four motors)
	Add the breadboard with the initial circuit to the chassis and screw them into place
	Position the wires from the motor to go through the chassis and connect them to the appropriate pins on the motor driver
Placing the sensors
	Place a bracket on the Plexiglas in order to place a bumper 
	Place another bracket on the chassis (front and back) so that the bracket is positioned upwards
	Mount a piece of Plexiglas with a length of the chassis (12.1cm) with a width of the GP2D12 distance sensor 
	Screw the distance sensors to the Plexiglas and tighten with a bolt
	Once the distance sensors are in place, connect the sensor wires to the appropriate atmega8 pins located on the breadboard
	Attach a bumper to the bracket located underneath the chassis for both the front and back of the robot
	Once the bumpers are attached, connect the line sensors to it and screw them into place and tighten with bolts
Placing the wheels
Connect the wheels to the motor and tighten them with screws
Block Diagram, Schematic, and software Flowchart 
Figure 31 shows the block diagram of the system. All inputs and outputs are shown. Figure 32 is the flowchart of the software algorithm. Finally, Figure 33 is the electrical schematic of the robot.
 
Figure 31: Block diagram of the robot
 
Figure 32: Flowchart of the algorithm
 
 
Figure 33: Robot schematic
 
Uploading the software to the robot
The following are the instructions on how to upload the software to the Tautologizer robot. 
Step 1
Open AVR studios
Step 2
Write the code in C
Step 3
Once the program has been successfully compiled, open PonyProg.exe
Step 4
In the I/O port setup in the setup tab (in menu), make sure to select:
Parallel
Aw ISP I/O 
LPT1
Step 5
Select File ? Open ? and select your hex file
Once you have located the file, double click on it to open
Step 6
Once the Hex file has been successfully loaded:
Connect the ISP cable (attached to the computer) and plug it in to the ISP head/reader (which is connected to the atmega8 on the circuit) so that the program may be uploaded to the microprocessor
Click the COMMAND tab in PonyProg menu and click WRITE ALL
Step 7
A window will pop up, and will ask to confirm the writing process
Click on ‘YES’ to confirm
NOTE: If the write is successful, a display message will pop up and display “WRITE SUCCESSFUL”, otherwise it will display “WRITE FAILED” 
You can now enjoy your Tautologizer robot.




 






Chapter 3: User Manual 
 
Welcome
Thank you for choosing the Tautologizer autonomous sumo robot! You’ve made an excellent choice and we hope that it will satisfy all of your requirements. 
The Tautologizer robot is an independent sumo robot optimized for one on one sumo robot competitions. It offers a wide set of functions while fighting an opposing robot. The Tautologizer tracks and detects opposing robots with the use is infrared sensors. Once an enemy has been detected and the Tautologizer has made contact, the motor strength is adjusted to help the Tautologizer push out the enemy out of the ring.
The Tautologizer is designed to deal with environmental constraints and can modify its actions based on the field it must perform on. 
About this Manual
Introduction
This user manual provides the user with the product overview and measurements. It also specifies how to operate the robot and outlines the safety precautions which must be taken into account when using the Tautologizer robot. 
Scope and Purpose
The manual provides the following:
	An overview of the final robot design
	The operation of the robot once it is turned on
	The safety precautions
	In depth description of how to maintain and debug the Tautologizer
Targeted Audience 
This manual is designed and developed for the users who are required to operate and perform the maintenance of robot. This manual will aid the operator to fully operate, understand and maintain the Tautologizer robot. 
Organization of this manual
About this manual
The user manual gives a brief overview of what this manual’s scope, targeted audience, and organization of this document. 
Product overview
The product overview section will show the final design specifications of the Tautologizer along with the measurements and dimensions of the robot.
How to switch the robot on
This section describes how to turn on the robot safely, and how the robot will operate once it is on. 
Safety Precautions
A list of safety precautions will be listed in order to not damage the Tautologizer robot.
Maintenance
This section will describe the maintenance needed on the robot after each use.
Debugging
The debugging section will show how to fix the robot in the event something has gone wrong.
Product overview 
The following figures represent the different possible views of the Tautologizer robot. From the figures, the robots mechanical aspects are extremely stable. When considering the electrical components, they are in the in the process of modified such that the robot looks aesthetically pleasing and will be ready for the final robot design. 
 
Figure 34: Front View
Figure 34 show the front view of the Tautologizer robot. Figure 35 shows the back view of the same robot. It can be noted that the front and the back of the robot are similar and this is due to the fact that the Tautologizer does not have a real front and back; the robot is symmetrical in design. This means that the Tautologizer can detect and attack opponents from both sides: front and back. 
Figure 36 shows the Tautologizer from one side. The other side is not shown since both sides are identical. 
 
Figure 35: Back View
 
Figure 36: Side View
 
Figure 37: Top View
 
Figure 38: Bottom View
Figure 37 shows the top view of the robot. The top of the robot is composed of the electrical components placed on two small breadboards. Finally, figure 38 shows the button of the Tautologizer. The bottom is reserved from the four motors and two battery packs. 
Table 20 shows the mechanical components list with their respective sizes. 
Table 20: Components sizes
Component	Size
Length of Robot	14.5 cm
Width of Robot	14 cm
Height of Robot	11.5 cm
Chassis	12.1x14.5 cm
Wheels	6.8 cm (diameter)
Support Plank	10x3.3 cm
Bumper	12x5.5 cm
Operation of the robot
The Tautologizer robot is an autonomous robot. This means that it operates on its own and does not require any outside help to operate other than turning the switch on. When turning on the robot, make sure to place in the ring in its proper position. This is to avoid the possibility of damaging any pieces due to unpredictable sensors data. 
How to turn on the robot
To turn on the Tautologizer robot, flip the switch to the operating position. Figure 39 shows the switch in the closed position.
 
Figure 39: The Switch
The environment it will be encountering
The Tautologizer robot is made to operate in any white field. Figure 40 is an example of a possible environment that the robot may encounter
 
Figure 40: The field
The environment that the robot will encounter will be a field of the same diameter as in figure 38, however, at the center of the ring, there will be a tower 1 foot in diameter and will act as an obstacle. 
How it will operate in its environment
When entering the ring, the robot is placed backwards with its front facing the line boundary. When the Tautologizer robot is ready to begin and the signal is given to start, turn the switch to the on position. The robot will have a delay of 5 seconds before moving. Once 5 seconds has passed, the robot will move forward and detect the boundary of the ring. It will then move backwards and rotate and then try to detect the opponent. The robot will detect the velocity of any moving object. If it detects an obstacle that has 0 velocity, then it has detected the tower and will move away and continue to search for an opposing robot. Once the opponent has been detected the Tautologizer will track it and proceed towards the opponent with an accelerated pace. Once the Tautologizer has made contact with the enemy the contact sensor will be enabled and the Tautologizer’s motors will be set to full power allowing it to have more pushing power ensuring the opponent is pushed out of the ring. This action may be used in either an offensive or defensive manner. 
Safety Precautions
The Tautologizer robot has many small components as well as many wires which might be easily pulled out. Therefore, when handling the robot outside of the ring, one must be very careful. This is to avoid any possible short circuits or wires pulling out. A short circuit would mean a possibility of very high current which could damage the circuit. When transporting the robot, the user should transport it in a container to avoid any possible contact with liquids. 
In order to prevent wires or components from popping out or loosening, one may use electrical tape to insulate some of the wires and avoid possible short circuits. For the mechanical components, the user can screw them into position and tighten them with bolts to keep them into place. 
When considering the battery pack, make sure that a tie-wrap is fastened tightly around it, along with the chassis to keep it into place. Make sure that the wires from the battery pack do not get tangled within the wheels. One way to avoid the wires from getting tangled with the wheels is to place the wires in between the battery pack, tie-wrap the batteries and place the wire through the chassis. 
Another concern is when placing the wires for the motor; they might get loose. One way to fix this issue is to place the wires in the hooks, and twist them so that they can not get out of position. Once in place, you may solder them into place. This is done to avoid loose wires so that there will not be any possibility of the wires getting tangled with an opposing robot or obstructing our path in any way. To solve this issue, one may keep all the wires in place by taping them with electrical tape. 
Before each battle it is important to verify that no wires get loose and that all wires are properly connected. If two or more wires were to touch each other a short circuit could occur causing potential damage to the robot. Therefore, it is very important to always keep a clean looking circuit. 
Maintenance of the Robot
Maintaining the robot is an extremely important process. You always want the Tautologizer robot to operate in its peak conditions. There are many things one must do in order to maintain the robot at its best performance. 
Maintaining the power source
Since the Tautologizer is an autonomous robot, it has its own power supply in the form of batteries. Over constant use of the Tautologizer robot, the batteries will lose charge and need to be replaced. The battery packs are located underneath the chassis in between the four motors. The battery packs are positioned in such a way that it is easy to replace the batteries whenever it is necessary. 
When changing the batteries, make sure to use good quality NiMH batteries. Good quality batteries will ensure that the robot will operate at maximum performance through the batteries lifespan. 
You should make sure to check the temperature of the battery packs after it has been used. If the battery packs are too hot, turn off the robot immediately and allow the battery packs to cool off and check for any possible damage to the robot. Overheated batteries may occur due to a short circuit which is extremely dangerous for the robots components. 
In the event of a short circuit
Short circuits are not desirable and dangerous to the robot, however there is a slight possibility that they occur. In the event of a short circuit, you may hear a crack or smell something burning. If this happens, immediately turn off the robots power supply. At this point, observe the robot and try to determine the source of the defective component. Once it has been located, simply replace the component and perform a series of tests to verify that nothing else in the circuit has been damaged. 
Rebooting the circuit
It is important for the circuit to always operate at its default conditions. This can be achieved with the use of the reset button. The reset is located on top of the robot and should be always pressed after turning on the power source.  
Debugging the Robot
There are several steps to follow in the event of the robot malfunction. The malfunction can be caused by any of the robot component which might cause an overall failure of the robot. Therefore, it is important to follow the below steps in order to isolate and resolve the robot failure. 
Check the connections
Begin by making sure all of the wires and components are properly attached and connected. A loose wire might cause a full breakdown of the robot, short circuits or malfunction of a specific component. In this case, refer to the technical manual to ensure the proper connections are done. 
 Testing the individual components
If all the connections look good and there are no loose wires you can start by testing individual components. Since all the components have specific functions, a malfunction in one can cause other components to respond in an unexpected manner. 
When considering the individual components begin by checking the voltage at the voltage regulator. The output voltage should be at 5V and if that is not the case consider replacing it. 
Once the voltage regulator is determined to be working properly, test the microcontroller. Test the input and output pins to make sure that they are operating properly. 
Next, check the distance sensors. Make sure that the voltage versus distance characteristics follows that of the data sheet’s characteristics. 
For the line sensors, check if the voltage level is high when it detects a black line and low at white line. A high is considered anything above 3V and a low anything under 1V. 
The contact sensors are normally high, when not pressed, and low when pressed. Once again, a high is anything above 3V and a low anything below 1V. 
Next check the voltage level of the motors with the oscilloscope probes. Do never measure the voltage directly across the H-bridge since this might cause the H-bridge to break. Place one probe on one side of the motor while the probe ground is connected to the real ground. Place the second probe at the other side of the motor. Using the oscilloscope measurement options display the difference in the two measured voltages. 
Debugging the robot as a whole
Repeat the steps in the above procedure, but this time with the whole circuit connected. Make sure that you obtain the appropriate voltages at the pins and make sure that none of the wire connections are loose. 
























Chapter 4: Software










The following section includes the software code in which was used for the Tautologizer robot. The code provided respects and outputs what has been outlined in section 1.13. 

#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdio.h>
#include <util/delay.h>
//TIMER DECLARATIONS
#define F_CPU				1000000UL
#define BAUD				4800
#define UBRR				((F_CPU/(16UL*BAUD))-1)
#define F_ISR_ADC			157
#define F_ISR_Serial		97

#define WIN_LED			PD0	//Winning LED
#define FRONT_LINE			PD2	//Front line sensor
#define BACK_LINE			PD3	//Back line sensor

#define FRONT_RIGHT_CONTACT	PD5	//Front right contact sensor
#define FRONT_LEFT_CONTACT	PB6	//Front left contact sensor
#define BACK_RIGHT_CONTACT	PB7	//Back right contact sensor
#define BACK_LEFT_CONTACT	PB0	//Back left contact sensor

#define FRONT_LEFT_IR		PC5	//Front IR sensor
#define FRONT_RIGHT_IR		PC4	//Front IR tower sensor
#define BACK_LEFT_IR		PC3	//Back IR sensor
#define BACK_RIGHT_IR		PC1	//Back IR tower sensor

#define RIGHT_PWM			PB2	//PWM for right motors
#define LEFT_PWM			PB1	//PWM for left motors

#define UNDETERMINED		0
#define STOP				1
#define FORWARD			2
#define BACKWARD			3
#define LEFT				4
#define RIGHT				5
#define ON				6
#define OFF				7
#define IN_RANGE			8
#define NOT_IN_RANGE		9

#define SPEED				75
#define STOP				255
#define SPEED_ATTACK		75		//This number will change

#define TIME_DELAY			20

void initPWM()
{
	OCR1A = 130;			//Set the value in the register to zero
	OCR1B = 130;
	TCCR1A=0X00;
	TCCR1A|=(1<<COM1A0)|(1<<COM1A1)|(1<<COM1B0)|(1<<COM1B1)|(1<<WGM10);   //Set OC1A/OC1B on Compare Match (Set output to high level)
	//WGM -> fast PWM 8-BIT
	DDRB|=(1<<PB1);		//Set OC1A PIN as output
	DDRB|=(1<<PB2);		//Set OC1B PIN as output
	DDRB|=(1<<PB3);		//1A and 4A right wheels
	DDRB|=(1<<PB4);		//2A and 3A right wheels	
	DDRD|=(1<<PD6);		//2A and 3A left wheels
	DDRD|=(1<<PD7);		//1A and 4A left wheel

	TCCR1B=0b00000001;			//Enable PWM
}

void initInputPorts()
{
	DDRD &= ~(1<<FRONT_LINE);
	DDRD &= ~(1<<BACK_LINE);
	
	DDRD &= ~(1<<FRONT_RIGHT_CONTACT);	//enable input
	PORTD |= (1<<FRONT_RIGHT_CONTACT);	//enable pull-up
	DDRB &= ~(1<<FRONT_LEFT_CONTACT);
	PORTB |= (1<<FRONT_LEFT_CONTACT);	//enable pull-up
	DDRB &= ~(1<<BACK_LEFT_CONTACT);
	PORTB |= (1<<BACK_LEFT_CONTACT);	//enable pull-up
	DDRB &= ~(1<<BACK_RIGHT_CONTACT);
	PORTB |= (1<<BACK_RIGHT_CONTACT);	//enable pull-up
	
	//DDRC &= ~(1<<Front_IR) | ~(1<<Front_IR_Tower) | ~(1<<Back_IR)| ~(1<<Back_IR_Tower);		//enable inputs not needed since used as ADC
	DDRD |= (1<<WIN_LED);														//enable outputs
}

//TODO: change TCNT0 to another counter because it is being used with timers and ADC
void initTimers()
{
	//This interrupt is enabled after system is turned on i.e. power on
	TCCR1B |= (1<<CS11)|(1<<CS10);				//16Bit counter, used for 1.8Hz with a 64 pre-scaler
	//TCNT1=56854;
	TCNT1=61195;								//In case we truly need to show with 1.8 Hz
	
	//This might have to be changed to something faster to check for line sensors
	TCCR0|=(1<<CS02)|(1<<CS00);					//8Bit counter, used to check B1	
	TCNT0=157;									//so that we have a 100ms with 1024 pre-scaler

	//The code below, check what type of interrupt we need	
	TIMSK|=(1<<TOIE1);							//For TIMER1_OVF_VECT
	TIMSK|=(1<<TOIE0);							//for TIMER0_OVF_VECT	
}

void initSerial()
{
	UCSRB=(1<<RXEN)|(1<<TXEN);	
	UCSRC=(1<<URSEL)|(1<<UCSZ0)|(1<<UCSZ1);
	UBRRL = UBRR;
	UBRRH = (UBRR>>8);	
}

void USART_vSendByte(char u8Data)
{
    while(!(UCSRA&(1<<UDRE)));		//Wait if a byte is being transmitted
    UDR = u8Data;					//Transmit data
}

void usart_write(char *str)
{
	int i=0;
	while(str[i]!= '\0')	
	{
		USART_vSendByte(str[i++]);
	}	
	USART_vSendByte('\r');
	USART_vSendByte('\n');
}

void initADC()
{
	//Internal 2.56V Voltage Reference with external capacitor at AREF pin
	//ADLAR: Left adjusted. Full data will be in ADCH
	ADMUX=0b11100101;//(1<<REFS1)|(1<<REFS0)|(1<<ADLAR);
	
	//Enabling ADC5 (front IR)
	//ADMUX|= (0101<<MUX0);
	
	//ADC enabled, ADC start (ADSC), Interrupt enable, pre-scaler of 8
	ADCSRA=(1<<ADEN)|(1<<ADSC)|(1<<ADIE)|(1<<ADPS1)|(1<<ADPS0);					
	//Set pre-scaler to 8 because (1MHz/8) = 125kHz ... ADC input frequency must be between 50kHz-200kHz
	
	//8Bit counter, used to check the ADC	
	TIMSK|=(1<<TOIE0);
	TCCR0=(1<<CS02)|(1<<CS00);
	TCNT0=F_ISR_ADC;
	sei();
}

/*
ADMUX bit MUX3 MUX2 MUX1 MUX0
ADC5 - 0101		case 0		- Front right sensor
ADC4 - 0100		case 1		- Front left sensor
ADC3 - 0011		case 2		- Back right sensor
ADC1 - 0001		case 3		- Back left sensor
*/
volatile uint8_t ADC_sensors = 0;
volatile uint8_t Front_right_IR_value = 0;
volatile uint8_t Front_right_IR_flag = 0;
volatile uint8_t Front_left_IR_value=0;
volatile uint8_t Front_left_IR_flag=0;
volatile uint8_t Back_right_IR_value = 0;
volatile uint8_t Back_right_IR_flag = 0;
volatile uint8_t Back_left_IR_value = 0;
volatile uint8_t Back_left_IR_flag = 0;

ISR(ADC_vect)
{
	cli();
	//ADMUX will jump to the next ADC pin, must consider the one in the initialize function
	switch(ADC_sensors)
	{
		case 0:
				Front_right_IR_value=ADCH;
				Front_right_IR_flag=ON;
				//ADMUX=(1<<REFS1)|(1<<REFS0)|(1<<ADLAR)|(0100<<MUX0);
				ADMUX=0b11100100;				//ADC4
				//Start conversion
				ADCSRA|=(1<<ADSC);	
				ADC_sensors++;			
				break;
		case 1:
				Front_left_IR_value=ADCH;
				Front_left_IR_flag=ON;
				//ADMUX=(1<<REFS1)|(1<<REFS0)|(1<<ADLAR)|(0011<<MUX0);
				ADMUX=0b11100011;				//ADC3
				//Start conversion
				ADCSRA|=(1<<ADSC);	
				ADC_sensors++;		
				break;
		case 2:
				Back_right_IR_value=ADCH;
				Back_right_IR_flag=ON;
				//ADMUX=(1<<REFS1)|(1<<REFS0)|(1<<ADLAR)|(0001<<MUX0);
				ADMUX=0b11100001;				//ADC1
				//Start conversion
				ADCSRA|=(1<<ADSC);				
				//start ADC for case 3
				ADC_sensors++;
				break;
		case 3:
				Back_left_IR_value=ADCH;
				Back_left_IR_flag=ON;
				//ADMUX=(1<<REFS1)|(1<<REFS0)|(1<<ADLAR)|(0101<<MUX0);
				ADMUX=0b11100101;				//ADC5
				//Do not start conversion, will do on next timer interrupt
				ADC_sensors=0;
				break;	
		default:
				ADC_sensors=0;
				ADMUX=0b11100101;				//ADC5				
				break;
	}
	sei();	
}

volatile uint8_t Front_line_flag=0;
volatile uint8_t Back_line_flag=0;
volatile uint8_t Delay_Back=OFF;
volatile uint8_t Delay_Front=OFF;

ISR(TIMER1_OVF_vect)
{
	cli();

	if(PIND&(1<<FRONT_LINE))
	{
		//_delay_ms(20);				//Delay for small period of time
		if(PIND&(1<<FRONT_LINE))	//check again
		{
			Front_line_flag=ON;
			Delay_Front=ON;
		}
	}
	else
	{
		Front_line_flag=OFF;
	}
	
	if(PIND&(1<<BACK_LINE))
	{
		//_delay_ms(20);				//Delay for small period of time
		if(PIND&(1<<BACK_LINE))	//check again
		{
			Back_line_flag=ON;
			Delay_Back=ON;
		}			
	}
	else
	{
		Back_line_flag=OFF;
	}
	
	if(PIND&(1<<FRONT_LINE) && PIND&(1<<BACK_LINE))
	{
		Front_line_flag=OFF;
		Back_line_flag=OFF;
		Delay_Front=OFF;
		Delay_Back=OFF;
	}
	
	TCNT1=65300;
	//TCNT1=65195;
	
	sei();	
}

volatile uint8_t Front_right_contact_flag = OFF;
volatile uint8_t Front_left_contact_flag = OFF;
volatile uint8_t Back_right_contact_flag = OFF;
volatile uint8_t Back_left_contact_flag = OFF;
volatile uint8_t win_flag = OFF;
volatile uint8_t win_counter = 0;
volatile uint8_t Front_line_counter=0;
volatile uint8_t Back_line_counter=0;

//I THINK THIS IS THE ISR FOR TIMER TCCR0
ISR(TIMER0_OVF_vect)
{
	//Should be WHILE the button is clicked no? Or is it already?
	cli();
	//Start ADC conversion
	ADCSRA|=(1<<ADSC);	
	//TCNT0=F_ISR_ADC;
	
	//Check for contact switches, goes LOW on contact
	
	if(PIND&(1<<FRONT_RIGHT_CONTACT))
	{
		Front_right_contact_flag = ON;
	}
	else
	{
		Front_right_contact_flag = OFF;
	}
	
	if(PINB&(1<<FRONT_LEFT_CONTACT))
	{
		Front_left_contact_flag = ON;
	}
	else
	{
		Front_left_contact_flag = OFF;
	}
	
	if(PINB&(1<<BACK_RIGHT_CONTACT))
	{
		Back_right_contact_flag = ON;
	}
	else
	{
		Back_right_contact_flag = OFF;
	}
	
	if(PINB&(1<<BACK_LEFT_CONTACT))
	{
		Back_left_contact_flag = ON;
	}
	else
	{
		Back_left_contact_flag = OFF;
	}
	
	
	if(win_flag == ON)
	{
		if(win_counter<50)
		{
			PORTD|=(1<<WIN_LED);
			win_counter++;
		}
		else
		{
			win_counter=0;
			win_flag=OFF;
		}
	}
	if(Delay_Back==ON)
	{
		if(Back_line_counter<TIME_DELAY)
		{
			Back_line_counter++;
		}
		else
		{
			Delay_Back=OFF;
			Back_line_counter=0;
		}
	}
	
	if(Delay_Front==ON)
	{
		if(Front_line_counter<TIME_DELAY)
		{
			Front_line_counter++;
		}
		else
		{
			Delay_Front=OFF;
			Front_line_counter=0;
		}
	}
	TCNT0=157;		//so that we have a 100ms with 1024 pre-scaler
	sei();
}

void setDirection(uint8_t _direction)
{
	//Testing to remove current spike
	OCR1A = STOP;
	OCR1B = STOP;
	PORTB&=~(1<<PB1);	
	PORTD&= ~(1<<PD7) & ~(1<<PD6);
	PORTB&=~(1<<PB4) & ~(1<<PB3);
	//_delay_ms(100);
	
	if(_direction==FORWARD)
	{
		//set to forward
		PORTD|=(1<<PD7);
		PORTD&=~(1<<PD6);	
		
		PORTB|=(1<<PB3);
		PORTB&=~(1<<PB4);
		
		OCR1A = SPEED;
		OCR1B = SPEED;
	}	
	else if(_direction==LEFT)
	{
		//left wheels forward (will turn right)
		PORTD|=(1<<PD7);
		PORTD&=~(1<<PD6);
		
		//stop right wheels
		PORTB&=~(1<<PB3);
		PORTB|=(1<<PB4);
		
		OCR1A = 85;
		OCR1B = 75;
	}	
	else if(_direction==RIGHT)
	{
		
		//stop left wheels
		PORTD&=~(1<<PD7);
		PORTD|=(1<<PD6);
		
		//right wheels forward (will turn left)
		PORTB|=(1<<PB3);
		PORTB&=~(1<<PB4);
		
		OCR1A = 75;
		OCR1B = 85;
	}			
	else
	{
		//set to backwards
		PORTD&=~(1<<PD7);
		PORTD|=(1<<PD6);		

		PORTB&=~(1<<PB3);
		PORTB|=(1<<PB4);
		
		OCR1A = SPEED;
		OCR1B = SPEED;
	}
}

int main(void)
{
	OCR1A = STOP;
	OCR1B = STOP;
	
	//wait 5 seconds
	_delay_ms(3000);
	
	initInputPorts();
//	initSerial();
	initADC();
	initTimers();
	initPWM();
		
	//char buffer[4] = {0};
	uint8_t front_right_detect=UNDETERMINED;
	uint8_t front_left_detect=UNDETERMINED;
	uint8_t back_right_detect=UNDETERMINED;
	uint8_t back_left_detect=UNDETERMINED;
	uint8_t old_direction=UNDETERMINED;		//Used after turning
	uint8_t direction=FORWARD;
	uint8_t object_in_front = OFF;
	uint8_t object_in_back = OFF;
	
	uint8_t enemy_detected=OFF;
	uint8_t tower_detected=OFF;
	uint8_t first_val=0, second_val=0;
	uint8_t first = OFF;
	uint8_t second = OFF;
	uint8_t check = 0;	
	int8_t delta = 0;

	setDirection(direction);
//	usart_write("HELLO WORLD");
	while(1)
    {
		if(Front_right_IR_flag==ON)
		{
			if(Front_right_IR_value>70)
			{
				//Set flag
				front_right_detect = IN_RANGE;
				front_left_detect=UNDETERMINED;
				
//				sprintf(buffer, "%u - %u",1,Front_right_IR_value);
//				usart_write(buffer);
			}
			else
			{
				front_right_detect = NOT_IN_RANGE;
			}
			
			//Used while pooling by ISR
			Front_right_IR_flag=OFF;
		}
		
		if(Front_left_IR_flag==ON)
		{
			if(Front_left_IR_value>86)
			{
				//Set flag
				front_left_detect = IN_RANGE;
//				sprintf(buffer, "%u - %u",5, Front_left_IR_value);
//				usart_write(buffer);				
			}
			else
			{
				front_left_detect = NOT_IN_RANGE;	
			}			
			//Used while pooling by ISR	
			Front_left_IR_flag=OFF;
		}
		
		if(Back_right_IR_flag==ON)
		{
			if(Back_right_IR_value>65)
			{
				//Set flag
				back_right_detect = IN_RANGE;						//It is visible in the allowed range
				back_left_detect = UNDETERMINED;
				
//				sprintf(buffer, "%u - %u",3, Back_right_IR_value);
//				usart_write(buffer);
			}
			else
			{
				back_right_detect = NOT_IN_RANGE;					//Can't see it, either out of range, or not there
			}
			
			//Used while pooling by ISR
			Back_right_IR_flag=OFF;
		}
		
		if(Back_left_IR_flag==ON)
		{
			if(Back_left_IR_value>65)
			{
				//set flag
				back_left_detect = IN_RANGE;
				
//				sprintf(buffer, "%u - %u",4, Back_left_IR_value);
//				usart_write(buffer);	
			}
			else
			{
				back_left_detect = NOT_IN_RANGE;				
			}		
			//Used while pooling by ISR
			Back_left_IR_flag=OFF;
		}	
		
		if(direction==FORWARD && (front_right_detect==IN_RANGE || front_left_detect==IN_RANGE) )
		{
			object_in_front=ON;			
			object_in_back=OFF;
		}
		else if (direction==BACKWARD && (back_right_detect==IN_RANGE || back_left_detect==IN_RANGE))
		{
			object_in_front=OFF;			
			object_in_back=ON;
		}
		else if((direction==FORWARD || old_direction==FORWARD) && (front_right_detect==NOT_IN_RANGE && front_left_detect==NOT_IN_RANGE))
		{
			object_in_front=OFF;
			//testing forward
			enemy_detected=OFF;
			tower_detected=OFF;
		}
		else if((direction==BACKWARD || old_direction==BACKWARD) && (back_right_detect==NOT_IN_RANGE && back_left_detect==NOT_IN_RANGE))
		{
			object_in_back=OFF;
			enemy_detected=OFF;
			tower_detected=OFF;			
		}
		
		//Find the enemy in front, push it
		if(front_right_detect==IN_RANGE && front_left_detect==IN_RANGE && Delay_Back==OFF)
		{
			if(direction==FORWARD && tower_detected==OFF && enemy_detected==OFF)
			{
				OCR1A = STOP;
				OCR1B = STOP;
				//testing
				_delay_ms(800);
				first = OFF;
				second = OFF;
				check = 0;
				while(first==OFF || second==OFF)
				{
					switch(check)
					{
						case 0:
								if(Front_right_IR_flag==ON)
								{
									first_val = Front_right_IR_value;
									first=ON;
									Front_right_IR_flag=OFF;
									check++;
								}
								break;
						case 1:
								if(Front_right_IR_flag==ON)
								{
									second_val = Front_right_IR_value;
									second=ON;
									Front_right_IR_flag=OFF;
									check++;
								}
								break;
						default:
								break;				
					}
				}
				delta = first_val-second_val;
				if(delta<-5 || delta > 5)
				{
					enemy_detected=ON;
					tower_detected=OFF;
				}	
				else
				{
					enemy_detected=OFF;
					tower_detected=ON;												
				}														
			}	
			
			if(enemy_detected==ON)
			{
				//enemy_in_front=ON;
				OCR1A = SPEED_ATTACK;
				OCR1B = SPEED_ATTACK;				
			}
			else if(object_in_back==OFF)
			{
				direction = FORWARD;
				setDirection(direction);
			}
			else if(enemy_detected==OFF)
			{
				old_direction=FORWARD;
			}
			
			/*
			if(direction==FORWARD)
			{
				//enemy_in_front=ON;
				OCR1A = SPEED_ATTACK;
				OCR1B = SPEED_ATTACK;
			}
			else if(enemy_in_back==OFF)
			{
				direction = FORWARD;
				setDirection(direction);
			}
			*/			
		}
		
		//Find the enemy in the back, push it
		if(back_right_detect==IN_RANGE && back_left_detect==IN_RANGE && Delay_Front==OFF)
		{

			if(direction==BACKWARD && tower_detected==OFF && enemy_detected==OFF)
			{
				OCR1A = STOP;
				OCR1B = STOP;
				//testing
				_delay_ms(800);
				first = OFF;
				second = OFF;
				check = 0;
				while(first==OFF || second==OFF)
				{
					switch(check)
					{
						case 0:
								if(Back_right_IR_flag==ON)
								{
									first_val = Front_right_IR_value;
									first=ON;
									Back_right_IR_flag=OFF;
									check++;
								}
								break;
						case 1:
								if(Back_right_IR_flag==ON)
								{
									second_val = Front_right_IR_value;
									second=ON;
									Back_right_IR_flag=OFF;
									check++;
								}
								break;
						default:
								break;				
					}
				}
				delta = first_val-second_val;
				if(delta<-5 || delta > 5)
				{
					enemy_detected=ON;
					tower_detected=OFF;
//					usart_write("ENEMY DETECTED");
					
				}	
				else
				{
				//	usart_write("TOWER DETECTED");
					enemy_detected=OFF;
					tower_detected=ON;												
				}														
				//get sensor data
				//get sensor data again
				//compare
			}	
			
			if(enemy_detected==ON)
			{
				//enemy_in_front=ON;
				OCR1A = SPEED_ATTACK;
				OCR1B = SPEED_ATTACK;				
			}
			else if(object_in_front==OFF)
			{
				direction = FORWARD;
				setDirection(direction);
			}
			else if(enemy_detected==OFF)
			{
				old_direction=BACKWARD;
			}
									
			/*
			if(direction==BACKWARD)
			{
			//	enemy_in_back=ON;
				OCR1A = SPEED_ATTACK;
				OCR1B = SPEED_ATTACK;
			}
			else if(object_in_front==OFF)
			{
				direction = BACKWARD;
				setDirection(direction);
			}	*/		
		}
						
		//Find the enemy on the front right, turn right until both sensors hit
		if(front_left_detect==NOT_IN_RANGE && front_right_detect==IN_RANGE && Delay_Back==OFF && object_in_back==OFF)
		{
//			usart_write("TURN RIGHT");
			if(direction!=RIGHT)
			{
				old_direction=FORWARD;
				direction = RIGHT;
				setDirection(direction);
			}
		}
		
		//Find the enemy on the front left, turn left until both sensors hit
		if(front_left_detect==IN_RANGE && front_right_detect==NOT_IN_RANGE && Delay_Back==OFF && object_in_back==OFF)
		{
//			usart_write("TURN LEFT");
			if(direction!=LEFT)
			{
				old_direction=FORWARD;
				direction = LEFT;
				setDirection(direction);
			}	
		}

		//Find the enemy on the back right, turn right
		if(back_left_detect==NOT_IN_RANGE && back_right_detect==IN_RANGE && Delay_Front==OFF && object_in_front==OFF)
		{
//			usart_write("TURN RIGHT");
			if(direction!=RIGHT)
			{
				old_direction=BACKWARD;
				direction = RIGHT;
				setDirection(direction);
			}
		}
		
		//Find the enemy on the back left, turn left
		if(back_left_detect==IN_RANGE && back_right_detect==NOT_IN_RANGE && Delay_Front==OFF && object_in_front==OFF)
		{
//			usart_write("TURN LEFT");
			if(direction!=LEFT)
			{
				old_direction=BACKWARD;
				direction = LEFT;			
				setDirection(direction);
			}
		}			
		
		//If we were turning and the tower is no longer in view reset direction
		if(old_direction==FORWARD && front_left_detect==IN_RANGE && front_right_detect==IN_RANGE)
		{
//			usart_write("MOVE FORWARD");
			direction=FORWARD;
			setDirection(direction);
			old_direction=UNDETERMINED;				
		}
		else if(old_direction==BACKWARD && back_left_detect==IN_RANGE && back_right_detect==IN_RANGE)
		{
//			usart_write("MOVE BACKWARD");			
			direction=BACKWARD;
			setDirection(direction);
			old_direction=UNDETERMINED;		
		}
		
		//If we hit the ring line with the front line sensor
		if(Front_line_flag==ON)
		{
//			usart_write("FRONT LINE DETECTED");
			//direction!=BACKWARD because we need to take in consideration left, right, and forward
			if(direction!=BACKWARD)
			{
				direction=BACKWARD;
				setDirection(direction);
				if(Front_right_contact_flag==ON)
				{
					//Celebrate for 5 seconds;
					win_flag=ON;
				}
			}
			else
			{
				//We are getting pushed or we are loosing.... 
				//Possible solution, set motors to as much power as possible
			}
		}	
		
		//If we hit the ring line with the back line sensor
		if(Back_line_flag==ON)
		{
//			usart_write("BACK LINE DETECTED");
			if(direction != FORWARD)
			{
				direction = FORWARD;
				setDirection(direction);
				
				if(Front_left_contact_flag==ON ||Front_right_contact_flag==ON)
				{
					//Celebrate for 5 seconds;
					win_flag=ON;
				}				
			}
			else
			{
				//We are getting pushed are we are loosing.... 
				//Possible solution, set motors to as much power as possible
			}
		}
		
		/*
		if(Front_left_contact_flag==ON)
			usart_write("FRONT LEFT CONTACT");
			
		if(Front_right_contact_flag==ON)
			usart_write("FRONT RIGHT CONTACT");	

		if(Back_left_contact_flag==ON)
			usart_write("BACK LEFT CONTACT");			
			
		if(Back_right_contact_flag==ON)
			usart_write("BACK RIGHT CONTACT");			
			*/
    }
}







 










Chapter 5: Bibliography







 

[1]	Passion computing. The Social Impact of Technology. [Online]. http://www.passioncomputing.com.au/articles/the-social-impact-of-technology.aspx

[2]	American Institute of Biological Sciences. (2004) Ethical Issues in Genetic Engineering and Transgenics. [Online]. http://www.actionbioscience.org/biotech/glenn.html

[3]	Auto and Light-truck systems. [Online]. http://207.5.42.159/sweethaven/MechTech/Automotive/Automotive02/default.asp?iNum=2&uNum=070101 

[4]	Pete Miles, Robot Sumo. Berkeley, California: McGraw-Hill/Osborne, 2002.
[5]	Sharp. GP2D/GP2D15 datasheet. [Online]. http://www.sharpsma.com/webfm_send/1204

[6]	TT Electronics OPTEK Technology. Reflective Object Sensor. [Online]. http://www.optekinc.com/datasheets/OPB606-607.PDF

[7]	Solarbotics. Gear Motor 2 – 224:1 Offset Shaft Datasheet. [Online]. http://content.solarbotics.com/products/datasheets/motor_data_summary-gm2.pdf

[8]	Solarbotics. Gear motor 8 – 143:1 Offset Shaft Datasheet. [Online]. http://content.solarbotics.com/products/datasheets/motor_data_summary-gm8.pdf

[9]	National Instruments. Differences between brushed and brushless DC motors. [Online]. http://digital.ni.com/public.nsf/allkb/1AFBCCE31476BD89862567D6007CA66D

[10]	Peter G. Dominick et Al Wiley, Tools and Tactics of Design - 1st edition., 2000.
[11]	Atmel. Atmega8 datasheet. [Online]. http://www.atmel.com/Images/doc2486.pdf

[12]	Optek. OPB606A Datasheet. [Online]. http://pdf1.alldatasheet.com/datasheet-pdf/view/80229/OPTEK/OPB606A.html


 
 
 
